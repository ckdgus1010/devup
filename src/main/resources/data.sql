-- 카테고리 (categories)
INSERT INTO categories
    (id, category, color)
VALUES
    (1, 'CI/CD', '#40C9A2'),
    (2, 'Database', '#FFD93D'),
    (3, 'Docker', '#F9F871'),
    (4, 'Frontend/React', '#E0AAFF'),
    (5, 'Git/GitHub', '#9D4EDD'),
    (6, 'HTTP', '#00C9A7'),
    (7, 'JPA', '#845EC2'),
    (8, 'Java', '#5F0F40'),
    (9, 'Linux', '#845EC2'),
    (10, 'MySQL', '#5F0F40'),
    (11, 'REST API', '#5F0F40'),
    (12, 'Redis', '#F9F871'),
    (13, 'Spring', '#73A9AD'),
    (14, 'Spring Boot', '#F9F871'),
    (15, 'Spring Security', '#40C9A2'),
    (16, '네트워크', '#FF6B6B'),
    (17, '로깅/모니터링', '#FF6F91'),
    (18, '보안', '#9D4EDD'),
    (19, '시스템 설계', '#F67280'),
    (20, '운영체제', '#FFD93D'),
    (21, '웹 인프라', '#40C9A2'),
    (22, '인증/인가', '#A2D2FF'),
    (23, '테스트', '#FFD93D');

-- 난이도 (levels)
INSERT INTO levels
    (id, level)
VALUES
    (1, 'EASY'),
    (2, 'MEDIUM'),
    (3, 'HARD');

-- 권한 (roles)
INSERT INTO roles
    (id, role_name, description, created_at)
VALUES
    (1, 'ROLE_USER', '일반 사용자', CURRENT_TIMESTAMP),
    (2, 'ROLE_ADMIN', '관리자', CURRENT_TIMESTAMP);

-- 사용자 (users)
INSERT INTO users
    (id, role_id, login_id, password, nickname, email, created_at)
VALUES
    (1, 1, 'user1', '$2a$12$L3hwEcWBtlbjNqbBO1Ukv.H2qYEprz6P9uylfT2RujWW9FiAEf9ve', '사용자1', 'user1@devup.com', CURRENT_TIMESTAMP),
    (2, 1, 'user2', '$2a$12$A5XbxYRC6WAEACzXW1QcpeKbr8NuFhcphfhACaXtRBjpWb2yACMvW', '사용자2', 'user2@devup.com', CURRENT_TIMESTAMP),
    (3, 1, 'user3', '$2a$12$7jpHtMMoVmHqQgw.mSgBPe8qnVXboRO3k920KCTbzChtHksJkfvo2', '사용자3', 'user3@devup.com', CURRENT_TIMESTAMP),
    (4, 1, 'user4', '$2a$12$0ZyGb/eUgu0JPRj8SAmTPuDQnJnV35cKT8ujJmBO0p73Nj/N/Sgw6', '사용자4', 'user4@devup.com', CURRENT_TIMESTAMP),
    (5, 1, 'user5', '$2a$12$xvsNuP8HD4S5pb.k908Bru1.jNzBfRnkaaVBFX.RisuHOglvYCUJy', '사용자5', 'user5@devup.com', CURRENT_TIMESTAMP),
    (6, 2, 'admin', '$2a$12$iLfO7X/iMCKIsNXGZMdlQu.QBwaHEHTj4QQkxA4VHGkP2.ij9L6NS', '관리자', 'admin@devup.com', CURRENT_TIMESTAMP);

-- 질문 (questions)
INSERT INTO questions
    (id, title, question_text, category_id, level_id, created_at, modified_at)
VALUES
    (1, 'Java의 예외 처리 방식과 사용자 정의 예외 활용', 'Java의 예외 처리 방식(checked, unchecked)을 비교하고, 사용자 정의 예외를 어떤 상황에서 활용하는지 설명해주세요.', 8, 2, '2025-01-01 00:00:00', NULL),
    (2, 'REST API에서 응답 일관성을 유지하기 위한 설계 전략', 'RESTful API를 설계할 때 모든 응답을 일관성 있게 유지하기 위한 구조 설계 방법을 설명해주세요.', 11, 3, '2025-01-01 10:37:36', NULL),
    (3, 'DB 트랜잭션 격리 수준의 종류와 발생 가능한 문제', '트랜잭션의 격리 수준(isolation level)에 따라 어떤 문제가 발생할 수 있는지 설명하고, 각각의 격리 수준에서 방지 가능한 현상을 정리해주세요.', 2, 3, '2025-01-01 21:15:13', NULL),
    (4, '스프링 시큐리티의 인증(Authentication)과 인가(Authorization)', '스프링 시큐리티에서 인증과 인가는 어떻게 동작하며, 필터 체인 내 어떤 시점에 처리되는지 설명해주세요.', 22, 2, '2025-01-02 07:52:50', NULL),
    (5, 'Docker 이미지 최적화 방법', 'Dockerfile을 작성할 때 이미지 크기를 줄이기 위한 대표적인 최적화 전략들을 설명해주세요.', 3, 1, '2025-01-02 18:30:26', NULL),
    (6, 'JVM 메모리 구조와 GC의 작동 영역', 'JVM의 메모리 구조를 설명하고, Garbage Collection은 어떤 영역에서 작동하며, 어떤 방식으로 객체를 관리하는지 설명해주세요.', 8, 3, '2025-01-03 05:08:03', NULL),
    (7, '서버 로드 밸런싱 방식 비교', '서버 로드 밸런싱에서 사용되는 대표적인 방식들을 비교하고, 각각의 장단점을 설명해주세요.', 19, 2, '2025-01-03 15:45:40', NULL),
    (8, 'CI/CD 파이프라인에서 테스트 단계의 역할', 'CI/CD 파이프라인에서 테스트 단계는 어떤 역할을 하며, 어떤 종류의 테스트가 포함될 수 있는지 설명해주세요.', 1, 1, '2025-01-04 02:23:17', NULL),
    (9, 'React에서 상태 관리 방식 비교', 'React에서 상태 관리를 위한 대표적인 방법들을 비교하고, 각각의 특징과 적합한 상황을 설명해주세요.', 4, 2, '2025-01-04 13:00:53', NULL),
    (10, 'SQL JOIN 종류와 각각의 사용 예시', 'SQL에서 사용되는 JOIN의 종류를 설명하고, 각각의 사용 사례를 예시와 함께 설명해주세요.', 2, 1, '2025-01-04 23:38:30', NULL),
    (11, 'Nginx 리버스 프록시 역할과 설정 예시', 'Nginx를 리버스 프록시로 사용할 때의 장점은 무엇이며, 기본적인 설정 예시는 어떤 형태인가요?', 21, 2, '2025-01-05 10:16:07', NULL),
    (12, 'TCP와 UDP의 차이점과 각각의 활용 사례', 'TCP와 UDP의 주요 차이점은 무엇이며, 각각 어떤 상황에서 사용하는 것이 적합한지 설명해주세요.', 16, 1, '2025-01-05 20:53:43', NULL),
    (13, 'Spring @Bean과 @Component의 차이', '@Bean과 @Component는 모두 스프링 빈을 등록하는데 사용됩니다. 각각의 차이점과 사용 시점을 설명해주세요.', 13, 2, '2025-01-06 07:31:20', NULL),
    (14, 'ElasticSearch의 기본 구조와 검색 방식', 'ElasticSearch의 인덱스, 도큐먼트, 샤드 등의 구조를 설명하고, 검색 요청이 어떻게 처리되는지 설명해주세요.', 17, 3, '2025-01-06 18:08:57', NULL),
    (15, 'JWT의 구조와 Signature의 역할', 'JWT 토큰의 구조를 설명하고, Signature가 어떤 역할을 수행하는지 구체적으로 설명해주세요.', 22, 1, '2025-01-07 04:46:34', NULL),
    (16, 'SQL 쿼리 튜닝을 위한 인덱스 전략', 'SQL 성능을 개선하기 위한 인덱스 설계 전략은 무엇이며, 실제로 적용할 때 주의할 점은 무엇인가요?', 2, 3, '2025-01-07 15:24:10', NULL),
    (17, '프론트엔드 번들링 도구와 트리 쉐이킹', '프론트엔드 빌드 도구(Webpack, Vite 등)에서 트리 쉐이킹(tree shaking)은 어떤 개념이며 어떤 상황에서 유용한가요?', 4, 2, '2025-01-08 02:01:47', NULL),
    (18, 'Spring Bean Scope의 종류와 특징', 'Spring Bean의 Scope는 어떤 종류들이 있으며, 각 스코프가 어떻게 다르게 동작하는지 설명해주세요.', 13, 1, '2025-01-08 12:39:24', NULL),
    (19, 'OSI 7계층과 웹 요청의 흐름', 'OSI 7계층의 개념을 간략히 설명하고, 브라우저가 HTTP 요청을 보낼 때 어떤 계층을 거치는지 설명해주세요.', 16, 2, '2025-01-08 23:17:00', NULL),
    (20, '로그 수집 파이프라인 구성 방식', '실제 서비스에서 로그를 수집하고 시각화하기 위한 파이프라인 구성 방식은 어떻게 되며, 각 구성요소의 역할은 무엇인가요?', 17, 2, '2025-01-09 09:54:37', NULL),
    (21, 'Docker 볼륨과 바인드 마운트의 차이', 'Docker에서 볼륨(volume)과 바인드 마운트(bind mount)는 어떤 차이점이 있으며, 각각 어떤 상황에서 사용하는 것이 적합한가요?', 3, 2, '2025-01-09 20:32:14', NULL),
    (22, 'Java Stream API의 장단점과 사용 사례', 'Java 8에 도입된 Stream API는 어떤 장점과 단점을 가지며, 주로 어떤 상황에서 사용하나요?', 8, 2, '2025-01-10 07:09:51', NULL),
    (23, 'JWT 탈취 방지를 위한 보안 전략', 'JWT는 클라이언트에 저장되므로 탈취 위험이 존재합니다. 이를 방지하기 위한 실무적인 보안 전략은 무엇이 있나요?', 18, 3, '2025-01-10 17:47:27', NULL),
    (24, '스프링 부트 자동 구성의 원리', '스프링 부트의 자동 구성(AutoConfiguration)이 동작하는 원리를 설명하고, 비활성화하거나 조건부 설정하는 방법을 설명해주세요.', 14, 3, '2025-01-11 04:25:04', NULL),
    (25, 'HTTP Keep-Alive의 개념과 이점', 'HTTP Keep-Alive는 어떤 개념이며, 이를 활성화하면 어떤 이점이 생기나요?', 6, 1, '2025-01-11 15:02:41', NULL),
    (26, 'JPA에서 영속성 컨텍스트의 역할', 'JPA에서 영속성 컨텍스트(Persistence Context)가 어떤 역할을 하며, 1차 캐시와 변경 감지 기능은 어떻게 동작하나요?', 7, 2, '2025-01-12 01:40:17', NULL),
    (27, 'Redis의 데이터 타입과 캐시 활용 전략', 'Redis에서 지원하는 주요 데이터 타입을 설명하고, 실무에서 어떤 전략으로 캐시를 구성하는지 설명해주세요.', 12, 2, '2025-01-12 12:17:54', NULL),
    (28, 'TCP 3-way Handshake와 연결 종료 과정', 'TCP에서 3-way Handshake를 통해 연결을 설정하는 과정과, 연결을 종료하는 과정(4-way handshake)을 설명해주세요.', 16, 1, '2025-01-12 22:55:31', NULL),
    (29, '프론트엔드의 CSR과 SSR 차이점', 'CSR(Client Side Rendering)과 SSR(Server Side Rendering)의 차이점을 설명하고, 각각 어떤 상황에서 적합한지 예시와 함께 설명해주세요.', 4, 1, '2025-01-13 09:33:08', NULL),
    (30, '스프링에서 예외 처리 통합 전략', '스프링에서 발생하는 예외를 통합적으로 처리하기 위한 전략은 무엇이며, @ControllerAdvice를 활용하는 방식은 어떻게 동작하나요?', 13, 3, '2025-01-13 20:10:44', NULL),
    (31, '리버스 프록시와 포워드 프록시의 차이', '리버스 프록시와 포워드 프록시는 어떤 구조적 차이가 있으며, 각각 어떤 용도로 사용되나요?', 21, 1, '2025-01-14 06:48:21', NULL),
    (32, 'JPA의 fetch join과 EntityGraph 차이', 'JPA에서 fetch join과 @EntityGraph는 모두 N+1 문제 해결에 쓰입니다. 각각의 특징과 차이점을 설명해주세요.', 7, 3, '2025-01-14 17:25:58', NULL),
    (33, '트랜잭션 전파 속성(Propagation) 종류와 동작 방식', 'Spring에서 트랜잭션 전파 속성(Propagation)의 종류는 어떤 것이 있으며, 각각 어떤 상황에서 사용하나요?', 13, 3, '2025-01-15 04:03:34', NULL),
    (34, 'OAuth 2.0 인증 흐름과 Refresh Token 역할', 'OAuth 2.0에서 인증 흐름은 어떻게 이루어지며, Refresh Token은 어떤 역할을 하나요?', 22, 2, '2025-01-15 14:41:11', NULL),
    (35, '로컬 개발 환경에서 HTTPS 적용 방법', '로컬 개발 환경에서 HTTPS를 적용하려면 어떤 방식으로 인증서를 발급하고 구성해야 하나요?', 18, 2, '2025-01-16 01:18:48', NULL),
    (36, 'MySQL InnoDB와 MyISAM의 차이', 'MySQL에서 InnoDB와 MyISAM 스토리지 엔진의 차이점을 기능적 측면에서 비교해주세요.', 2, 2, '2025-01-16 11:56:25', NULL),
    (37, '스프링 AOP 동작 방식과 실무 적용 예시', '스프링 AOP가 동작하는 방식과 실무에서 활용할 수 있는 예시를 설명해주세요.', 13, 3, '2025-01-16 22:34:01', NULL),
    (38, '브라우저 렌더링 과정 요약', '브라우저가 HTML을 받아 사용자 화면에 표시하기까지의 렌더링 과정을 요약해서 설명해주세요.', 4, 1, '2025-01-17 09:11:38', NULL),
    (39, 'API 게이트웨이의 역할과 주요 기능', 'API Gateway가 마이크로서비스 아키텍처에서 어떤 역할을 하며, 주요 기능은 무엇인가요?', 19, 2, '2025-01-17 19:49:15', NULL),
    (40, 'CORS 개념과 설정 방식', '웹 개발에서 자주 등장하는 CORS(Cross-Origin Resource Sharing)의 개념을 설명하고, 이를 설정하는 방법을 설명해주세요.', 18, 1, '2025-01-18 06:26:51', NULL),
    (41, 'Spring Security 필터 체인 동작 순서', 'Spring Security에서 인증과 인가가 이루어지는 필터 체인의 주요 흐름을 설명해주세요.', 15, 3, '2025-01-18 17:04:28', NULL),
    (42, '스프링 빈 생명주기에서 @PostConstruct와 InitializingBean의 차이', '@PostConstruct와 InitializingBean 인터페이스는 모두 빈 초기화에 사용됩니다. 각각의 차이점과 사용 예시를 설명해주세요.', 13, 2, '2025-01-19 03:42:05', NULL),
    (43, 'DB 샤딩과 파티셔닝의 차이점', '데이터베이스에서 샤딩(sharding)과 파티셔닝(partitioning)은 모두 데이터를 분산시키는 방법입니다. 이 둘의 개념과 차이점을 설명해주세요.', 2, 3, '2025-01-19 14:19:42', NULL),
    (44, 'OAuth 2.0 Authorization Code Grant 흐름', 'OAuth 2.0의 Authorization Code Grant 방식에서 사용자의 로그인부터 토큰 발급까지의 흐름을 설명해주세요.', 22, 3, '2025-01-20 00:57:18', NULL),
    (45, '프론트엔드에서 Debounce와 Throttle 차이', 'Debounce와 Throttle은 모두 이벤트 과잉 호출을 방지하는 기법입니다. 둘의 차이와 사용 사례를 설명해주세요.', 4, 2, '2025-01-20 11:34:55', NULL),
    (46, '로그 레벨(Level)의 종류와 사용 기준', '로그를 작성할 때 사용하는 로그 레벨(Level)의 종류는 어떤 것들이 있으며, 각각 어떤 기준으로 사용해야 하나요?', 17, 1, '2025-01-20 22:12:32', NULL),
    (47, 'JPA에서 save()와 persist()의 차이', 'JPA에서 save()와 persist()는 모두 데이터를 저장하는 데 사용됩니다. 둘의 차이점을 설명해주세요.', 7, 2, '2025-01-21 08:50:08', NULL),
    (48, '서버 장애를 빠르게 감지하기 위한 모니터링 구성', '실서비스에서 장애를 빠르게 인지하고 대응하기 위한 모니터링 시스템은 어떻게 구성하면 좋을까요?', 19, 2, '2025-01-21 19:27:45', NULL),
    (49, 'HTTP 상태코드 2xx, 4xx, 5xx 계열 비교', 'HTTP 상태 코드에서 2xx, 4xx, 5xx 계열의 의미를 비교해서 설명해주세요.', 6, 1, '2025-01-22 06:05:22', NULL),
    (50, 'Spring에서 @ConfigurationProperties의 역할과 장점', '@ConfigurationProperties는 어떤 용도로 사용되며, @Value와 비교했을 때 어떤 장점이 있나요?', 14, 2, '2025-01-22 16:42:59', NULL),
    (51, 'Spring에서 @RequestParam과 @PathVariable의 차이', '스프링 웹 애플리케이션에서 @RequestParam과 @PathVariable은 모두 요청 값을 전달받을 때 사용됩니다. 두 어노테이션의 차이점과 사용 예시를 설명해주세요.', 13, 1, '2025-01-23 03:20:35', NULL),
    (52, 'JPA에서 영속성 전이(Cascade)의 의미와 사용 주의점', 'JPA에서 Cascade 설정은 연관 엔티티에 자동으로 작업을 전파하는 기능입니다. cascade의 의미와 실제 사용 시 주의할 점을 설명해주세요.', 7, 2, '2025-01-23 13:58:12', NULL),
    (53, 'SPA에서 페이지 이동과 상태 관리', 'SPA(Single Page Application)에서 페이지 이동은 어떻게 처리되며, 상태 관리는 어떤 방식으로 이루어지나요?', 4, 2, '2025-01-24 00:35:49', NULL),
    (54, 'Redis pub/sub 구조와 사용 사례', 'Redis의 pub/sub 기능은 어떤 구조로 작동하며, 실무에서 어떻게 활용할 수 있나요?', 12, 2, '2025-01-24 11:13:25', NULL),
    (55, '브라우저의 캐시 정책과 Cache-Control 헤더', '웹에서 성능 최적화를 위해 캐시가 사용됩니다. Cache-Control 헤더를 이용한 캐시 제어 방식과 주의할 점을 설명해주세요.', 21, 2, '2025-01-24 21:51:02', NULL),
    (56, 'API 응답 속도 개선을 위한 캐시 전략', '대규모 트래픽이 발생하는 API에서 응답 속도를 개선하기 위한 캐시 전략은 어떤 방식들이 있을까요?', 19, 2, '2025-01-25 08:28:39', NULL),
    (57, 'JWT와 세션 기반 인증의 구조적 차이', 'JWT 기반 인증 방식과 전통적인 세션 기반 인증 방식은 어떤 구조적 차이와 장단점을 가지고 있나요?', 22, 2, '2025-01-25 19:06:16', NULL),
    (58, '리액트 컴포넌트 성능 최적화 방법', 'React에서 컴포넌트의 렌더링 성능을 최적화하기 위한 대표적인 방법들을 설명해주세요.', 4, 2, '2025-01-26 05:43:52', NULL),
    (59, 'HTTP와 HTTPS의 차이와 SSL/TLS의 역할', 'HTTP와 HTTPS의 차이점을 설명하고, HTTPS가 보안을 보장하는 방식에 대해 설명해주세요.', 6, 1, '2025-01-26 16:21:29', NULL),
    (60, '스프링에서 RestTemplate과 WebClient의 차이', 'Spring에서 HTTP 요청을 보내기 위해 사용하는 RestTemplate과 WebClient는 어떤 차이점이 있고, 각각 어떤 상황에 적합한가요?', 13, 2, '2025-01-27 02:59:06', NULL),
    (61, 'MySQL 트랜잭션과 COMMIT, ROLLBACK', 'MySQL에서 트랜잭션은 어떤 개념이며, COMMIT과 ROLLBACK 명령어는 어떤 역할을 하나요?', 2, 1, '2025-01-27 13:36:42', NULL),
    (62, '스프링에서 @Value와 @ConfigurationProperties 비교', 'Spring Boot에서 @Value와 @ConfigurationProperties는 모두 설정값을 주입할 수 있습니다. 둘의 차이점과 장단점을 비교해주세요.', 14, 2, '2025-01-28 00:14:19', NULL),
    (63, 'JWT 구조의 세 가지 구성 요소', 'JWT(Json Web Token)는 어떤 구조로 이루어져 있으며, 각각의 역할은 무엇인가요?', 22, 1, '2025-01-28 10:51:56', NULL),
    (64, 'React 상태 관리 시 전역 상태의 필요성과 대안', 'React 애플리케이션에서 상태 관리 시 전역 상태가 필요한 상황은 어떤 경우이며, 어떤 도구를 사용할 수 있나요?', 4, 2, '2025-01-28 21:29:33', NULL),
    (65, 'CI와 CD의 개념 및 차이점', '소프트웨어 개발에서 CI와 CD는 무엇을 의미하며, 각각 어떤 역할을 하나요?', 1, 1, '2025-01-29 08:07:09', NULL),
    (66, '데이터베이스 정규화의 개념과 장단점', '데이터베이스 정규화(Normalization)의 목적은 무엇이며, 장단점은 어떤 것이 있나요?', 2, 2, '2025-01-29 18:44:46', NULL),
    (67, 'Spring의 빈 스코프 중 request, session 차이', '스프링 웹 애플리케이션에서 request, session 스코프의 차이점과 사용 시 주의할 점을 설명해주세요.', 13, 2, '2025-01-30 05:22:23', NULL),
    (68, '쿠키와 세션의 차이와 보안 고려사항', '웹에서 쿠키와 세션은 모두 상태 유지를 위해 사용됩니다. 두 방식의 차이점과 보안 측면에서의 고려사항을 설명해주세요.', 18, 1, '2025-01-30 16:00:00', NULL),
    (69, '프론트엔드 코드 분할(Code Splitting)의 필요성과 방법', '프론트엔드에서 코드 분할(Code Splitting)은 왜 필요한가요? React에서는 어떤 방식으로 구현할 수 있나요?', 4, 2, '2025-01-31 02:37:36', NULL),
    (70, 'CDN의 역할과 캐시 갱신 전략', 'CDN(Content Delivery Network)의 주요 역할과, 정적 자원의 캐시 갱신을 위한 전략을 설명해주세요.', 21, 2, '2025-01-31 13:15:13', NULL),
    (71, '인터페이스와 추상 클래스의 차이와 선택 기준', 'Java에서 인터페이스와 추상 클래스는 모두 추상화를 위한 구조입니다. 이 둘의 차이점과 어떤 기준으로 선택해야 하는지 설명해주세요.', 8, 2, '2025-01-31 23:52:50', NULL),
    (72, 'JPA merge() 동작 방식과 주의점', 'JPA에서 merge() 메서드는 어떤 상황에서 사용되며, 동작 방식과 함께 주의할 점을 설명해주세요.', 7, 3, '2025-02-01 10:30:26', NULL),
    (73, 'Spring Filter와 Interceptor의 차이', 'Spring MVC에서 Filter와 Interceptor는 요청을 가로채는 데 사용됩니다. 이 둘의 차이점과 각각의 사용 목적을 설명해주세요.', 13, 2, '2025-02-01 21:08:03', NULL),
    (74, 'HTTP 요청 메서드별 용도 비교', 'HTTP에서 GET, POST, PUT, DELETE, PATCH 메서드는 각각 어떤 용도로 사용되며, 주요 차이점을 설명해주세요.', 6, 1, '2025-02-02 07:45:40', NULL),
    (75, 'useEffect 훅의 의존성 배열 사용법', 'React에서 useEffect 훅은 컴포넌트 생명주기 처리를 위해 사용됩니다. 의존성 배열의 역할과 잘못 사용했을 때의 문제점을 설명해주세요.', 4, 2, '2025-02-02 18:23:17', NULL),
    (76, 'SQL에서 GROUP BY와 HAVING의 차이', 'SQL 쿼리에서 GROUP BY와 HAVING은 함께 자주 사용됩니다. 각각의 역할과 차이점을 설명해주세요.', 2, 1, '2025-02-03 05:00:53', NULL),
    (77, 'Spring에서 예외 발생 시 HTTP 상태 코드 처리 방식', '스프링 MVC에서 예외가 발생했을 때 적절한 HTTP 상태 코드를 응답하기 위해 어떤 처리 전략을 사용할 수 있나요?', 13, 2, '2025-02-03 15:38:30', NULL),
    (78, 'React에서 키 값(key)의 중요성', 'React에서 리스트를 렌더링할 때 key 값을 지정해야 하는 이유는 무엇이며, 잘못 지정하면 어떤 문제가 생길 수 있나요?', 4, 1, '2025-02-04 02:16:07', NULL),
    (79, 'OAuth 2.0 Implicit Grant의 특징과 보안 문제', 'OAuth 2.0의 Implicit Grant 방식은 어떤 특징을 가지며, 왜 보안상 문제가 될 수 있나요?', 22, 3, '2025-02-04 12:53:43', NULL),
    (80, '동기 vs 비동기 처리의 개념과 적용 예시', '동기(Synchronous)와 비동기(Asynchronous) 처리의 차이점을 설명하고, 각각의 예시를 들어주세요.', 19, 1, '2025-02-04 23:31:20', NULL),
    (81, 'Spring의 @Transactional이 동작하지 않는 경우', '@Transactional 어노테이션이 붙어 있어도 트랜잭션이 적용되지 않는 대표적인 상황들을 설명해주세요.', 13, 3, '2025-02-05 10:08:57', NULL),
    (82, '인덱스가 SELECT 성능에는 도움이 되지만 INSERT 성능은 떨어뜨리는 이유', '데이터베이스에서 인덱스는 SELECT 성능을 높여주지만, INSERT/UPDATE 성능에는 악영향을 줄 수 있습니다. 그 이유를 설명해주세요.', 2, 2, '2025-02-05 20:46:34', NULL),
    (83, 'JWT 토큰이 만료되었을 때 사용자 경험 처리 전략', 'JWT 기반 인증 시스템에서 액세스 토큰이 만료되었을 때 어떤 방식으로 사용자 경험을 처리할 수 있을까요?', 22, 2, '2025-02-06 07:24:10', NULL),
    (84, 'CSR과 SSR을 혼합한 전략: Hydration', 'CSR과 SSR의 장점을 모두 취하려는 전략으로 Hydration이 사용됩니다. 이 개념과 작동 방식을 설명해주세요.', 4, 3, '2025-02-06 18:01:47', NULL),
    (85, '클라우드 환경에서의 무중단 배포 전략', 'AWS, GCP 같은 클라우드 환경에서 무중단 배포를 실현하기 위한 전략에는 어떤 것들이 있나요?', 1, 3, '2025-02-07 04:39:24', NULL),
    (86, 'Java의 Optional 클래스 사용 목적과 장단점', 'Java 8부터 도입된 Optional 클래스는 어떤 문제를 해결하기 위한 도구이며, 장단점은 무엇인가요?', 8, 2, '2025-02-07 15:17:00', NULL),
    (87, 'JPA 페치 전략 EAGER vs LAZY', 'JPA에서 연관관계의 페치 전략(FetchType.EAGER vs LAZY)은 각각 어떤 동작을 하며, 어떤 기준으로 선택해야 하나요?', 7, 2, '2025-02-08 01:54:37', NULL),
    (88, 'React 컴포넌트 재사용을 위한 설계 전략', 'React에서 재사용 가능한 컴포넌트를 설계하기 위해 고려해야 할 주요 원칙은 무엇인가요?', 4, 2, '2025-02-08 12:32:14', NULL),
    (89, 'TCP와 UDP를 선택하는 기준', 'TCP와 UDP는 각각 어떤 특징을 가지며, 어떤 상황에서 각각을 선택하면 좋을까요?', 16, 1, '2025-02-08 23:09:51', NULL),
    (90, 'CI/CD에서 테스트 자동화의 중요성과 구성 방식', 'CI/CD 파이프라인에서 테스트 자동화는 왜 중요한가요? 어떤 방식으로 구성할 수 있나요?', 1, 2, '2025-02-09 09:47:27', NULL),
    (91, 'RESTful URI 설계 시 지켜야 할 원칙', 'RESTful API 설계에서 URI를 구성할 때 어떤 원칙을 따라야 하며, 흔히 발생하는 안티패턴은 어떤 것들이 있나요?', 11, 2, '2025-02-09 20:25:04', NULL),
    (92, 'JPA에서 @MappedSuperclass의 역할', 'JPA에서 @MappedSuperclass는 어떤 용도로 사용되며, @Entity와는 어떤 차이가 있나요?', 7, 2, '2025-02-10 07:02:41', NULL),
    (93, 'CSR 환경에서 SEO 대응 전략', 'CSR 기반의 React 앱은 초기 렌더링 시 HTML 콘텐츠가 없기 때문에 검색 엔진 최적화(SEO)에 불리합니다. 이를 극복하기 위한 전략은 무엇이 있나요?', 4, 3, '2025-02-10 17:40:17', NULL),
    (94, 'Nginx에서 gzip 압축 설정 이유와 방법', 'Nginx에서 정적 자원을 gzip 압축하여 전달하는 설정은 왜 필요하며, 어떻게 구성하나요?', 21, 1, '2025-02-11 04:17:54', NULL),
    (95, 'OAuth와 OpenID Connect의 차이', 'OAuth 2.0과 OpenID Connect는 둘 다 인증 시스템에 사용됩니다. 이 두 기술의 차이점과 관계를 설명해주세요.', 22, 2, '2025-02-11 14:55:31', NULL),
    (96, 'JPA에서 영속성 컨텍스트와 1차 캐시의 관계', 'JPA에서 영속성 컨텍스트는 1차 캐시로 동작한다고 합니다. 이 구조가 성능에 어떤 영향을 주며, 어떤 경우 문제가 발생할 수 있나요?', 7, 2, '2025-02-12 01:33:08', NULL),
    (97, 'Spring의 @Async 사용 시 주의할 점', 'Spring에서 @Async 어노테이션을 사용하면 비동기 처리가 가능해집니다. 사용 시 주의해야 할 주요 사항은 무엇인가요?', 13, 3, '2025-02-12 12:10:44', NULL),
    (98, 'CSR에서 초기 로딩 최적화를 위한 전략', 'CSR 기반의 애플리케이션에서 초기 로딩 속도를 개선하기 위한 대표적인 전략에는 무엇이 있나요?', 4, 2, '2025-02-12 22:48:21', NULL),
    (99, '3계층 아키텍처 구조와 각 계층 역할', '웹 애플리케이션의 3계층 아키텍처는 어떤 계층으로 구성되며, 각 계층의 역할은 무엇인가요?', 19, 1, '2025-02-13 09:25:58', NULL),
    (100, 'OAuth 2.0의 4가지 인증 방식 비교', 'OAuth 2.0에서는 4가지 인증 방식(Authorization Code, Implicit, Password, Client Credentials)을 지원합니다. 각각의 특징과 사용 상황을 비교해주세요.', 22, 3, '2025-02-13 20:03:34', NULL),
    (101, 'JPA에서 N+1 문제를 해결하는 방법', 'JPA에서 연관 엔티티를 조회할 때 발생하는 N+1 문제는 성능에 치명적일 수 있습니다. 이를 해결하기 위한 대표적인 전략들을 설명해주세요.', 7, 3, '2025-02-14 06:41:11', NULL),
    (102, 'Spring의 빈 등록 우선순위 결정 방식', '스프링에서 동일 타입의 Bean이 여러 개 등록되었을 때 어떤 방식으로 주입 대상이 결정되며, 이를 제어하는 방법은 무엇인가요?', 13, 2, '2025-02-14 17:18:48', NULL),
    (103, 'React에서 상태 끌어올리기(Lifting State Up)', 'React에서 하위 컴포넌트 간에 상태를 공유하려면 상태 끌어올리기(Lifting State Up) 기법을 사용합니다. 이 개념과 적용 방법을 설명해주세요.', 4, 1, '2025-02-15 03:56:25', NULL),
    (104, 'HSTS의 개념과 웹 보안에서의 역할', 'HSTS(HTTP Strict Transport Security)는 어떤 보안 기능이며, 어떻게 작동하나요?', 18, 2, '2025-02-15 14:34:01', NULL),
    (105, '무결성 제약 조건의 종류와 사용 목적', 'RDB에서 무결성(Integrity) 제약 조건은 데이터 정합성을 보장하기 위해 사용됩니다. 대표적인 제약 조건의 종류와 예시를 설명해주세요.', 2, 1, '2025-02-16 01:11:38', NULL),
    (106, 'JPA @OneToMany 관계에서 mappedBy의 의미', 'JPA에서 @OneToMany 관계를 맺을 때 자주 등장하는 mappedBy 속성은 어떤 의미이며, 어떤 역할을 하나요?', 7, 2, '2025-02-16 11:49:15', NULL),
    (107, 'Spring에서 @Scope를 사용한 Bean 범위 지정', 'Spring Framework에서 @Scope 어노테이션은 어떤 용도로 사용되며, 주요 스코프의 종류는 무엇이 있나요?', 13, 1, '2025-02-16 22:26:51', NULL),
    (108, 'React에서 이벤트 위임(Event Delegation) 처리 방식', '브라우저에서는 이벤트 위임(Event Delegation)을 통해 성능을 최적화합니다. React에서는 이 개념을 어떻게 구현하고 활용하나요?', 4, 2, '2025-02-17 09:04:28', NULL),
    (109, 'XSS 공격 개념과 방어 전략', 'XSS(Cross-Site Scripting) 공격은 웹 보안에서 자주 언급됩니다. 이 공격의 개념과 이를 방어하기 위한 주요 전략은 무엇인가요?', 18, 2, '2025-02-17 19:42:05', NULL),
    (110, '로드 밸런싱 알고리즘의 종류와 특징', '로드 밸런서를 구성할 때 선택할 수 있는 다양한 알고리즘이 있습니다. 대표적인 알고리즘 종류와 각 특징을 설명해주세요.', 19, 2, '2025-02-18 06:19:42', NULL),
    (111, 'JPA 영속성 전이(Cascade)와 고아 객체 제거(OrphanRemoval)', 'JPA에서 Cascade와 OrphanRemoval 옵션은 연관관계 관리를 자동화하는 데 사용됩니다. 각각의 개념과 차이점을 설명해주세요.', 7, 3, '2025-02-18 16:57:18', NULL),
    (112, 'Spring Bean 생명주기와 초기화/소멸 처리 방식', 'Spring에서 Bean의 생성부터 소멸까지 생명주기 관리를 할 수 있습니다. Bean의 생명주기와 초기화/소멸 처리 방법을 설명해주세요.', 13, 2, '2025-02-19 03:34:55', NULL),
    (113, 'React에서 커스텀 훅(Custom Hook)의 목적과 사용 예시', 'React에서 Custom Hook은 코드 재사용성을 높이기 위한 도구입니다. Custom Hook의 개념과 사용 예시를 설명해주세요.', 4, 2, '2025-02-19 14:12:32', NULL),
    (114, '브루트 포스 공격과 방어 전략', '브루트 포스 공격(Brute Force Attack)은 인증 시스템에서 흔히 발생하는 공격입니다. 이 공격의 개념과 방어 전략은 무엇인가요?', 18, 2, '2025-02-20 00:50:08', NULL),
    (115, 'RDB vs NoSQL의 구조적 차이와 선택 기준', '관계형 데이터베이스(RDB)와 NoSQL의 구조적 차이를 비교하고, 어떤 기준으로 선택하면 좋은지 설명해주세요.', 19, 2, '2025-02-20 11:27:45', NULL),
    (116, 'JPA의 Dirty Checking 개념과 동작 원리', 'JPA에서는 엔티티 변경 시 save()를 호출하지 않아도 자동으로 DB에 반영됩니다. 이를 가능하게 하는 Dirty Checking의 개념과 동작 방식을 설명해주세요.', 7, 2, '2025-02-20 22:05:22', NULL),
    (117, 'Spring에서 ApplicationContext와 BeanFactory의 차이', 'Spring에서 ApplicationContext와 BeanFactory는 모두 DI 컨테이너로 사용됩니다. 두 인터페이스의 차이점은 무엇인가요?', 13, 2, '2025-02-21 08:42:59', NULL),
    (118, 'React에서 useMemo와 useCallback의 차이', 'React에서 성능 최적화를 위해 useMemo와 useCallback 훅을 사용할 수 있습니다. 이 둘의 차이점은 무엇인가요?', 4, 2, '2025-02-21 19:20:35', NULL),
    (119, 'CSRF 공격 개념과 방어 전략', 'CSRF(Cross-Site Request Forgery) 공격은 사용자 의지와 무관한 요청을 발생시켜 서버를 조작하는 방식입니다. 이를 방어하기 위한 전략은 무엇인가요?', 18, 3, '2025-02-22 05:58:12', NULL),
    (120, '도메인 주도 설계(DDD)의 핵심 개념', 'DDD(Domain Driven Design)는 복잡한 도메인을 효과적으로 설계하기 위한 접근입니다. DDD의 핵심 개념을 정리해주세요.', 19, 3, '2025-02-22 16:35:49', NULL),
    (121, 'JPA @Version을 이용한 낙관적 락', 'JPA에서 동시성 문제를 해결하기 위해 낙관적 락을 적용할 수 있습니다. @Version 어노테이션을 사용하는 방법과 동작 원리를 설명해주세요.', 7, 3, '2025-02-23 03:13:25', NULL),
    (122, 'Spring에서 @ComponentScan과 basePackages의 의미', 'Spring에서 @ComponentScan 어노테이션은 어떤 역할을 하며, basePackages 속성은 어떤 상황에서 사용되나요?', 13, 2, '2025-02-23 13:51:02', NULL),
    (123, 'React에서 Controlled vs Uncontrolled Component', 'React에서 Controlled Component와 Uncontrolled Component의 차이점과 각각의 사용 예시를 설명해주세요.', 4, 2, '2025-02-24 00:28:39', NULL),
    (124, 'SQL Injection 공격과 방어 방법', 'SQL Injection은 입력값을 조작해 악의적인 SQL을 실행하는 공격입니다. 이 공격의 예시와 방어 전략을 설명해주세요.', 18, 3, '2025-02-24 11:06:16', NULL),
    (125, '모놀리식 vs 마이크로서비스 아키텍처', '소프트웨어 아키텍처에서 모놀리식 구조와 마이크로서비스 구조의 차이점과 각각의 장단점을 설명해주세요.', 19, 2, '2025-02-24 21:43:52', NULL),
    (126, 'JPA에서 Entity와 DTO의 명확한 역할 분리', 'JPA 기반 애플리케이션에서는 Entity와 DTO를 구분해서 사용하는 것이 중요하다고 합니다. 두 객체의 역할과 분리 이유를 설명해주세요.', 7, 2, '2025-02-25 08:21:29', NULL),
    (127, 'Spring @Configuration과 @Bean의 의미', 'Spring에서 @Configuration과 @Bean 어노테이션은 어떤 목적을 위해 사용되며, 이 둘은 어떤 관계가 있나요?', 13, 1, '2025-02-25 18:59:06', NULL),
    (128, 'React에서 useEffect 클린업 함수의 역할', 'React의 useEffect 훅 내부에서 return문으로 클린업 함수를 정의할 수 있습니다. 이 함수는 어떤 시점에 호출되며 어떤 역할을 하나요?', 4, 2, '2025-02-26 05:36:42', NULL),
    (129, '보안의 3대 요소: 기밀성, 무결성, 가용성', '정보 보안의 기본 개념으로 CIA 삼각형(기밀성, 무결성, 가용성)이 자주 언급됩니다. 각 요소의 의미를 간단히 설명해주세요.', 18, 1, '2025-02-26 16:14:19', NULL),
    (130, '마이크로서비스에서 서비스 간 통신 방식 비교', '마이크로서비스 아키텍처에서는 서비스 간 통신이 중요합니다. 동기식(REST)과 비동기식(Message Queue) 통신 방식의 차이점과 각각의 장단점을 설명해주세요.', 19, 3, '2025-02-27 02:51:56', NULL),
    (131, 'JPA에서 지연 로딩과 즉시 로딩의 차이', 'JPA에서는 연관 관계를 맺을 때 지연 로딩(LAZY)과 즉시 로딩(EAGER)을 선택할 수 있습니다. 이 두 전략의 차이점과 장단점을 설명해주세요.', 7, 2, '2025-02-27 13:29:33', NULL),
    (132, 'Spring AOP에서 Pointcut과 Advice의 역할', 'Spring AOP는 관심사를 분리하기 위한 도구입니다. 이 중 Pointcut과 Advice는 어떤 역할을 수행하며, 어떻게 동작하나요?', 13, 3, '2025-02-28 00:07:09', NULL),
    (133, 'React에서 비동기 상태 처리 방식', 'React 애플리케이션에서 비동기 API 호출을 처리하고 상태를 관리하는 대표적인 방식은 무엇이며, 각각의 특징은 어떤가요?', 4, 2, '2025-02-28 10:44:46', NULL),
    (134, 'SSL/TLS 핸드셰이크 과정', 'HTTPS에서 사용되는 SSL/TLS는 핸드셰이크 과정을 통해 암호화 통신을 설정합니다. 이 핸드셰이크의 핵심 과정은 무엇인가요?', 18, 3, '2025-02-28 21:22:23', NULL),
    (135, '마이크로서비스의 장애 전파와 서킷 브레이커 패턴', '마이크로서비스 환경에서 한 서비스의 장애가 전체 시스템으로 확산되지 않게 하려면 어떤 방법이 필요할까요? 대표적인 패턴을 설명해주세요.', 19, 3, '2025-03-01 08:00:00', NULL),
    (136, 'JPA에서 @ManyToOne과 @JoinColumn의 관계', '@ManyToOne과 함께 자주 사용되는 @JoinColumn 어노테이션은 어떤 역할을 하며, 생략했을 때 어떤 일이 발생하나요?', 7, 2, '2025-03-01 18:37:36', NULL),
    (137, 'Spring MVC의 DispatcherServlet 동작 원리', 'Spring MVC의 핵심 구성 요소 중 하나인 DispatcherServlet은 어떤 역할을 하며, 요청이 들어왔을 때 어떤 순서로 처리가 이루어지나요?', 13, 3, '2025-03-02 05:15:13', NULL),
    (138, 'React의 key 속성의 필요성과 주의점', 'React에서 list를 렌더링할 때 key 속성을 설정하는 이유는 무엇이며, 잘못 사용할 경우 발생할 수 있는 문제는 무엇인가요?', 4, 1, '2025-03-02 15:52:50', NULL),
    (139, 'OAuth 2.0에서 Refresh Token의 동작 원리', 'OAuth 2.0에서는 Access Token과 함께 Refresh Token을 발급하기도 합니다. Refresh Token의 역할과 동작 원리를 설명해주세요.', 18, 3, '2025-03-03 02:30:26', NULL),
    (140, '서버 간 데이터 동기화 시 고려사항', '마이크로서비스나 분산 시스템에서 데이터 동기화를 수행할 때 어떤 요소들을 고려해야 하며, 주로 어떤 방식이 사용되나요?', 19, 3, '2025-03-03 13:08:03', NULL),
    (141, 'JPA Native Query와 JPQL의 차이', 'JPA에서는 JPQL과 Native Query를 모두 사용할 수 있습니다. 두 쿼리 방식의 차이점과 각각의 장단점을 설명해주세요.', 7, 2, '2025-03-03 23:45:40', NULL),
    (142, 'Spring에서 Environment와 @Value 차이', 'Spring에서 프로퍼티 값을 읽을 수 있는 방법으로 Environment 객체와 @Value 어노테이션이 있습니다. 이 둘의 차이점과 각각의 사용 예시를 설명해주세요.', 13, 2, '2025-03-04 10:23:17', NULL),
    (143, 'React Portal의 개념과 활용 사례', 'React에서는 일반적인 컴포넌트 트리 외부에 렌더링할 수 있는 Portal 기능을 제공합니다. Portal의 개념과 활용 사례를 설명해주세요.', 4, 2, '2025-03-04 21:00:53', NULL),
    (144, '보안 인증 vs 인가의 차이', '웹 보안에서 인증(Authentication)과 인가(Authorization)는 다른 개념입니다. 두 개념의 차이점을 간단히 설명해주세요.', 18, 1, '2025-03-05 07:38:30', NULL),
    (145, 'API 게이트웨이 vs 서비스 메시', '마이크로서비스 아키텍처에서 자주 비교되는 API 게이트웨이와 서비스 메시의 역할과 차이를 설명해주세요.', 19, 3, '2025-03-05 18:16:07', NULL),
    (146, 'JPA에서 fetch join의 역할과 주의점', 'JPA에서 연관된 엔티티를 함께 조회하기 위해 fetch join을 사용할 수 있습니다. fetch join의 개념과 사용 시 주의할 점을 설명해주세요.', 7, 3, '2025-03-06 04:53:43', NULL),
    (147, 'Spring의 Bean 순환 참조 문제와 해결책', 'Spring에서는 생성자 주입 시 Bean 간 순환 참조가 발생하면 애플리케이션이 실행되지 않습니다. 순환 참조의 원인과 해결 방법을 설명해주세요.', 13, 3, '2025-03-06 15:31:20', NULL),
    (148, 'React에서 context API의 사용 목적', 'React의 Context API는 어떤 상황에서 사용하면 좋은가요? Props Drilling 문제와의 관계도 함께 설명해주세요.', 4, 2, '2025-03-07 02:08:57', NULL),
    (149, 'HTTPS의 보안 요소: 암호화, 무결성, 인증', 'HTTPS는 HTTP에 SSL/TLS를 적용한 보안 프로토콜입니다. HTTPS가 제공하는 주요 보안 기능 3가지를 설명해주세요.', 18, 2, '2025-03-07 12:46:34', NULL),
    (150, '마이크로서비스에서 API 버전 관리 전략', '마이크로서비스 API를 운영할 때 여러 버전을 관리하는 것이 중요합니다. REST API에서 버전 관리를 위한 전략을 설명해주세요.', 19, 3, '2025-03-07 23:24:10', NULL),
    (151, 'JPA @Embedded와 @Embeddable의 용도', 'JPA에서 @Embedded와 @Embeddable 어노테이션은 어떤 상황에서 사용되며, 그 목적은 무엇인가요?', 7, 2, '2025-03-08 10:01:47', NULL),
    (152, 'Spring에서 프로파일(Profile)의 역할', 'Spring Framework에서 @Profile 어노테이션은 어떤 목적으로 사용되며, 어떤 경우 유용한가요?', 13, 1, '2025-03-08 20:39:24', NULL),
    (153, 'React에서 useRef의 동작 방식과 활용', 'React에서 useRef 훅은 어떤 용도로 사용되며, 일반적인 상태(state)와는 어떤 차이가 있나요?', 4, 2, '2025-03-09 07:17:00', NULL),
    (154, '보안 토큰의 종류: Access vs Refresh vs ID Token', 'OAuth 2.0과 OpenID Connect에서 사용되는 Access Token, Refresh Token, ID Token은 각각 어떤 역할을 하나요?', 18, 3, '2025-03-09 17:54:37', NULL),
    (155, '마이크로서비스 환경의 트랜잭션 처리 전략', '마이크로서비스 아키텍처에서는 서비스 간 분산 트랜잭션이 어렵습니다. 이를 해결하기 위한 전략으로 어떤 것들이 있고, 어떤 상황에서 사용되나요?', 19, 3, '2025-03-10 04:32:14', NULL),
    (156, 'JPA 영속성 컨텍스트의 생명주기', 'JPA에서 영속성 컨텍스트는 엔티티를 관리하는 핵심 요소입니다. 영속성 컨텍스트의 생명주기 단계와 각 단계의 특징을 설명해주세요.', 7, 2, '2025-03-10 15:09:51', NULL),
    (157, 'Spring Bean 초기화 순서와 의존성 주입', 'Spring Bean이 생성되고 주입되는 순서에는 일정한 생명주기 흐름이 있습니다. 이 흐름과 의존성 주입 시점에 대해 설명해주세요.', 13, 2, '2025-03-11 01:47:27', NULL),
    (158, 'React에서 useMemo 사용 시점과 주의점', 'React에서 useMemo 훅은 어떤 상황에서 사용해야 하며, 남용했을 때 어떤 문제가 발생할 수 있나요?', 4, 2, '2025-03-11 12:25:04', NULL),
    (159, 'Hashing vs Encryption', '보안에서 해싱(Hashing)과 암호화(Encryption)는 자주 혼동됩니다. 이 둘의 차이점과 사용 목적을 설명해주세요.', 18, 2, '2025-03-11 23:02:41', NULL),
    (160, '마이크로서비스에서 API 게이트웨이의 역할', '마이크로서비스 아키텍처에서 API Gateway는 중요한 구성 요소입니다. API Gateway의 주요 역할과 도입 시 얻을 수 있는 장점을 설명해주세요.', 19, 2, '2025-03-12 09:40:17', NULL),
    (161, 'JPA에서 QueryDsl의 장점과 사용 목적', 'JPA에서 QueryDsl을 사용하는 이유는 무엇인가요? JPQL과 비교했을 때의 장점도 함께 설명해주세요.', 7, 3, '2025-03-12 20:17:54', NULL),
    (162, 'Spring에서 @Transactional(readOnly = true)의 효과', '@Transactional(readOnly = true)를 사용하면 어떤 효과가 있으며, 언제 사용하면 좋은가요?', 13, 2, '2025-03-13 06:55:31', NULL),
    (163, 'React에서 상태를 전역으로 관리하는 방법', 'React에서는 여러 컴포넌트 간 상태를 공유할 때 전역 상태 관리가 필요합니다. 어떤 도구들을 사용할 수 있으며, 각각의 특징은 무엇인가요?', 4, 2, '2025-03-13 17:33:08', NULL),
    (164, '보안 공격 기법: MITM(중간자 공격)', 'MITM(Man-In-The-Middle) 공격이란 무엇이며, 이를 방지하기 위해 어떤 대책을 사용할 수 있을까요?', 18, 2, '2025-03-14 04:10:44', NULL),
    (165, '마이크로서비스 운영 시 서비스 디스커버리의 역할', '마이크로서비스 아키텍처에서 서비스 디스커버리는 어떤 역할을 하며, 대표적인 구현 방법에는 무엇이 있나요?', 19, 2, '2025-03-14 14:48:21', NULL),
    (166, 'Redis에서 pub/sub의 개념과 활용 사례', 'Redis는 pub/sub 기능을 제공합니다. 이 기능의 개념과 실제 활용할 수 있는 사례를 설명해주세요.', 12, 2, '2025-03-15 01:25:58', NULL),
    (167, 'Docker에서 볼륨(Volume)의 역할', 'Docker에서 볼륨(Volume)은 어떤 목적을 위해 사용되며, 바인드 마운트와는 어떤 차이가 있나요?', 3, 2, '2025-03-15 12:03:34', NULL),
    (168, 'Linux의 systemctl 명령어와 서비스 관리', 'Linux 시스템에서 systemctl 명령어는 어떤 역할을 하며, 자주 사용하는 명령어를 예시와 함께 설명해주세요.', 9, 2, '2025-03-15 22:41:11', NULL),
    (169, '로그 수집에서 Filebeat와 Logstash의 역할 비교', '로그 수집 파이프라인에서 Filebeat와 Logstash는 어떤 차이점이 있으며, 각자의 역할은 무엇인가요?', 17, 2, '2025-03-16 09:18:48', NULL),
    (170, 'Mockito에서 @Mock과 @InjectMocks의 차이', 'Mockito에서 단위 테스트를 작성할 때 자주 사용하는 @Mock과 @InjectMocks의 차이점은 무엇인가요?', 23, 2, '2025-03-16 19:56:25', NULL),
    (171, 'Redis의 TTL(Time To Live) 기능', 'Redis는 캐시를 저장하는 데 자주 사용되며, TTL(Time To Live) 기능이 중요한 역할을 합니다. TTL의 개념과 주요 사용 사례를 설명해주세요.', 12, 1, '2025-03-17 06:34:01', NULL),
    (172, 'Docker 이미지와 컨테이너의 개념 차이', 'Docker에서 이미지(Image)와 컨테이너(Container)는 어떤 개념이며, 두 개념의 차이점은 무엇인가요?', 3, 1, '2025-03-17 17:11:38', NULL),
    (173, 'Linux에서 파일 권한 구조와 chmod 명령어', 'Linux에서 파일의 권한 구조는 어떻게 구성되어 있으며, chmod 명령어를 통해 권한을 어떻게 변경할 수 있나요?', 9, 2, '2025-03-18 03:49:15', NULL),
    (174, 'ELK Stack의 구성 요소와 역할', 'ELK Stack은 로그 수집과 분석을 위한 대표적인 오픈소스 스택입니다. 각각의 구성 요소(Elasticsearch, Logstash, Kibana)의 역할을 설명해주세요.', 17, 2, '2025-03-18 14:26:51', NULL),
    (175, 'JUnit의 단위 테스트 구조와 @Test 어노테이션', 'JUnit을 활용해 단위 테스트를 작성할 때 자주 사용하는 어노테이션은 무엇이며, @Test의 역할은 무엇인가요?', 23, 1, '2025-03-19 01:04:28', NULL),
    (176, 'Spring Boot의 AutoConfiguration 개념', 'Spring Boot에서는 AutoConfiguration 기능을 통해 설정을 자동화합니다. 이 기능의 개념과 내부 동작 방식을 설명해주세요.', 14, 2, '2025-03-19 11:42:05', NULL),
    (177, 'REST API의 HATEOAS 원칙', 'REST API 설계 원칙 중 HATEOAS는 자주 생략되지만, 중요한 개념입니다. HATEOAS의 의미와 적용 시 얻을 수 있는 이점을 설명해주세요.', 11, 3, '2025-03-19 22:19:42', NULL),
    (178, 'Spring Security에서 OAuth2 로그인 흐름', 'Spring Security에서 OAuth2 기반 소셜 로그인을 구현할 때 어떤 흐름으로 동작하며, 주요 설정 포인트는 무엇인가요?', 22, 3, '2025-03-20 08:57:18', NULL),
    (179, '3-way Handshake 과정과 목적', 'TCP 통신을 시작할 때 사용하는 3-way Handshake 과정은 어떤 순서로 진행되며, 그 목적은 무엇인가요?', 16, 1, '2025-03-20 19:34:55', NULL),
    (180, 'Git에서 Merge Conflict 해결 방법', 'Git에서 브랜치를 병합할 때 충돌(Merge Conflict)이 발생하는 경우가 있습니다. 충돌의 원인과 해결 방법을 설명해주세요.', 5, 2, '2025-03-21 06:12:32', NULL),
    (181, 'Spring Boot Starter의 역할과 구조', 'Spring Boot에서는 다양한 starter 의존성을 제공합니다. starter의 개념과 내부적으로 어떤 구조로 동작하는지 설명해주세요.', 14, 1, '2025-03-21 16:50:08', NULL),
    (182, 'RESTful URI 설계의 좋은 예와 나쁜 예', 'REST API를 설계할 때 URI는 리소스를 표현하는 중요한 수단입니다. RESTful하지 않은 URI의 예와 개선된 URI 예시를 들어 설명해주세요.', 11, 1, '2025-03-22 03:27:45', NULL),
    (183, 'JWT의 구조와 보안 고려사항', 'JWT(Json Web Token)는 토큰 기반 인증에서 자주 사용됩니다. JWT의 구조와 사용할 때 주의해야 할 보안 이슈를 설명해주세요.', 22, 2, '2025-03-22 14:05:22', NULL),
    (184, '도메인 설계에서 Bounded Context의 개념', '도메인 주도 설계(DDD)에서는 Bounded Context가 핵심 개념으로 등장합니다. 이 개념의 의미와 실제 프로젝트에서 어떻게 적용되는지 설명해주세요.', 19, 2, '2025-03-23 00:42:59', NULL),
    (185, 'Git rebase의 개념과 merge와의 차이점', 'Git에서 브랜치를 관리할 때 rebase를 사용할 수 있습니다. rebase의 개념과 merge와의 차이점을 설명해주세요.', 5, 3, '2025-03-23 11:20:35', NULL),
    (186, 'MySQL에서 트랜잭션의 ACID 특성', 'MySQL은 트랜잭션을 통해 데이터 무결성을 보장합니다. 트랜잭션의 4가지 ACID 특성을 각각 설명해주세요.', 10, 2, '2025-03-23 21:58:12', NULL),
    (187, 'Spring Boot에서 application.yml의 프로파일 구성', 'Spring Boot에서 환경별 설정을 분리할 때 application.yml은 어떻게 구성하며, 프로파일을 어떻게 활성화하나요?', 14, 1, '2025-03-24 08:35:49', NULL),
    (188, 'Redis의 영속성 방식: RDB vs AOF', 'Redis는 인메모리 데이터베이스지만 데이터를 영구 보관하기 위해 RDB와 AOF 방식을 지원합니다. 두 방식의 차이점과 장단점을 설명해주세요.', 12, 3, '2025-03-24 19:13:25', NULL),
    (189, 'Linux에서 crontab 사용법과 주기 설정 예시', 'Linux에서 crontab은 반복 작업 자동화에 사용됩니다. crontab의 형식과 실행 주기를 설정하는 방법을 설명하고 예시를 들어보세요.', 9, 1, '2025-03-25 05:51:02', NULL),
    (190, 'GitHub Pull Request 리뷰 프로세스', 'GitHub에서 Pull Request(PR)를 올린 후 코드 리뷰는 어떻게 진행되며, 협업 과정에서 어떤 점을 고려해야 하나요?', 5, 2, '2025-03-25 16:28:39', NULL),
    (191, 'MySQL의 인덱스 선택 기준과 주의점', 'MySQL에서 인덱스를 잘못 사용하면 오히려 성능이 나빠질 수 있습니다. 인덱스를 적용할 때 어떤 기준을 따르고, 어떤 점에 주의해야 하나요?', 10, 3, '2025-03-26 03:06:16', NULL),
    (192, 'Spring Boot Actuator의 주요 기능', 'Spring Boot에서는 Actuator를 통해 운영 및 모니터링 정보를 제공합니다. Actuator에서 제공하는 주요 기능은 무엇이며, 어떤 상황에 유용하게 활용될 수 있나요?', 14, 2, '2025-03-26 13:43:52', NULL),
    (193, 'Redis의 LRU 캐시 정책과 적용 예시', 'Redis는 메모리 부족 시 데이터를 제거하는 정책으로 LRU를 사용할 수 있습니다. LRU의 동작 방식과 실제 어떤 상황에서 활용될 수 있는지 설명해주세요.', 12, 2, '2025-03-27 00:21:29', NULL),
    (194, 'Linux top 명령어로 시스템 리소스 분석하기', 'Linux에서 top 명령어는 시스템 성능을 실시간으로 확인할 수 있는 도구입니다. 어떤 정보들을 확인할 수 있으며, 주요 지표의 의미를 설명해주세요.', 9, 2, '2025-03-27 10:59:06', NULL),
    (195, 'Git의 stash 기능과 활용 사례', 'Git에서는 작업 도중 임시로 변경 사항을 저장해둘 수 있는 stash 기능을 제공합니다. 이 기능의 개념과 자주 쓰이는 명령어, 활용 사례를 설명해주세요.', 5, 1, '2025-03-27 21:36:42', NULL),
    (196, 'Dockerfile에서 multi-stage build의 목적', 'Dockerfile을 작성할 때 multi-stage build를 사용하는 이유는 무엇이며, 어떤 이점을 제공하나요?', 3, 2, '2025-03-28 08:14:19', NULL),
    (197, '운영체제의 프로세스와 스레드의 차이', '운영체제에서 프로세스와 스레드는 모두 실행 단위를 나타냅니다. 이 둘의 구조적 차이와 자원 공유 측면의 차이를 설명해주세요.', 20, 2, '2025-03-28 18:51:56', NULL),
    (198, '테스트에서 통합 테스트와 단위 테스트의 차이', '소프트웨어 테스트에서 단위 테스트(unit test)와 통합 테스트(integration test)의 차이점과 각각의 목적을 설명해주세요.', 23, 1, '2025-03-29 05:29:33', NULL),
    (199, 'Git에서 rebase의 위험성과 사용 주의점', 'Git에서 rebase는 히스토리를 깔끔하게 정리할 수 있는 도구지만 주의가 필요합니다. rebase 사용 시 주의할 점과 잘못 사용했을 때 발생할 수 있는 문제를 설명해주세요.', 5, 3, '2025-03-29 16:07:09', NULL),
    (200, 'Prometheus와 Grafana의 역할 차이', '서비스 모니터링 시스템에서 Prometheus와 Grafana는 자주 함께 사용됩니다. 각 도구의 역할과 서로 어떻게 협력하는지 설명해주세요.', 17, 2, '2025-03-30 02:44:46', NULL),
    (201, 'CI/CD 파이프라인에서 GitHub Actions의 역할', 'CI/CD 파이프라인을 구축할 때 GitHub Actions를 사용하는 사례가 많습니다. GitHub Actions의 개념과 주요 구성 요소, 실제 활용 예시를 설명해주세요.', 1, 2, '2025-03-30 13:22:23', NULL);

-- 정답 (answers)
INSERT INTO answers
    (question_id, answer_text, created_at, modified_at)
VALUES
    (1, 'Checked 예외는 컴파일 타임에 처리 강제, Unchecked 예외는 런타임에 발생합니다. 예를 들어 FileNotFoundException은 반드시 try-catch로 처리해야 합니다. 사용자 정의 예외는 도메인 로직에서 의미 있는 오류를 표현할 때 사용하며, 서비스의 예외 흐름을 명확하게 만드는 데 도움이 됩니다. `extends RuntimeException`으로 정의하고, 메시지와 상태 코드 등을 포함할 수 있습니다.', '2025-01-01 00:00:00', NULL),
    (2, '모든 응답은 공통된 Response 객체 형태로 감싸서 내려주는 것이 좋습니다. 예를 들어 `{ data, message, status }` 구조를 사용하면 클라이언트가 일관되게 응답을 처리할 수 있습니다. 예외 처리 또한 전역 예외 핸들러(@ControllerAdvice)에서 처리해 status code와 message를 통일성 있게 반환해야 합니다. 실제 프로젝트에서는 ResponseEntity를 래핑한 커스텀 응답 객체를 도입하기도 합니다.', '2025-01-01 10:37:36', NULL),
    (3, '격리 수준이 낮을수록 동시성은 높지만 정합성 문제 발생 가능성이 큽니다.
    - **Read Uncommitted**: Dirty Read 허용
    - **Read Committed**: Dirty Read 방지
    - **Repeatable Read**: Non-repeatable Read 방지
    - **Serializable**: Phantom Read까지 방지
    적절한 격리 수준을 설정하지 않으면 데이터 이상 현상이 발생할 수 있습니다. MySQL InnoDB의 기본 수준은 Repeatable Read입니다.', '2025-01-01 21:15:13', NULL),
    (4, '인증은 사용자의 신원을 확인하는 과정이고, 인가는 권한을 검사하는 단계입니다.
    스프링 시큐리티는 UsernamePasswordAuthenticationFilter에서 인증을 처리하고, 이후 FilterSecurityInterceptor에서 인가를 검사합니다. 인증 정보는 SecurityContextHolder에 저장되며, 이후 컨트롤러에서 @AuthenticationPrincipal 등을 통해 접근할 수 있습니다.', '2025-01-02 07:52:50', NULL),
    (5, '이미지를 경량화하려면 다음과 같은 전략을 사용합니다:
    - 다단계 빌드(multi-stage build)로 불필요한 빌드 도구 제거
    - 불필요한 파일은 `.dockerignore`로 제외
    - base 이미지로 `alpine`과 같은 경량 이미지를 사용
    - 레이어 수를 줄이기 위해 RUN 명령어를 하나로 묶기
    이러한 전략은 빌드 속도와 배포 효율성을 높여줍니다.', '2025-01-02 18:30:26', NULL),
    (6, 'JVM 메모리는 메서드 영역, 힙, 스택, PC 레지스터, 네이티브 메서드 스택으로 구성됩니다. GC는 주로 힙 영역에서 동작하며, Young, Old, Metaspace로 구분됩니다. 객체는 Eden → Survivor → Old 순으로 이동하며, Young GC는 Minor GC, Old GC는 Major 또는 Full GC로 처리됩니다. GC 알고리즘에는 G1, CMS, Serial 등이 있으며, 각각의 특징에 따라 성능과 처리 방식이 달라집니다.', '2025-01-03 05:08:03', NULL),
    (7, '로드 밸런싱에는 라운드로빈, Least Connection, IP 해시 방식 등이 있습니다. 라운드로빈은 순차적으로 분배해 간단하지만, 처리량이 다른 서버에서는 부적절할 수 있습니다. Least Connection은 현재 연결 수가 적은 서버에 요청을 보내 효율적이지만 상태 추적 비용이 듭니다. IP 해시는 클라이언트 고정 세션에 적합하지만 서버 추가 시 해시 충돌 문제가 발생할 수 있습니다.', '2025-01-03 15:45:40', NULL),
    (8, '테스트 단계는 배포 전에 코드 품질과 기능의 정상 동작을 검증하기 위한 단계입니다. 단위 테스트, 통합 테스트, E2E 테스트 등이 여기에 포함되며, 실패 시 배포를 중단함으로써 품질을 보장합니다. 자동화된 테스트 도구와 리포트를 함께 구성하면 문제가 발생한 위치를 빠르게 파악할 수 있습니다.', '2025-01-04 02:23:17', NULL),
    (9, 'React는 useState, useReducer, Context API, Redux 등 다양한 상태 관리 방법을 제공합니다. useState는 컴포넌트 내부 상태 관리에 적합하고, useReducer는 복잡한 로직 처리 시 효과적입니다. Context API는 전역 상태 공유에 유용하지만 성능 이슈가 있을 수 있고, Redux는 대규모 상태 관리를 위해 미들웨어와 함께 강력한 도구를 제공합니다.', '2025-01-04 13:00:53', NULL),
    (10, 'INNER JOIN은 두 테이블에 모두 존재하는 데이터만, LEFT JOIN은 왼쪽 테이블 기준으로, RIGHT JOIN은 오른쪽 테이블 기준으로 NULL 포함 결과를 반환합니다. FULL OUTER JOIN은 양쪽 모두 포함하며, 주로 PostgreSQL 등에서 지원됩니다. 예: 사용자와 주문 테이블에서 INNER JOIN은 주문한 사용자만, LEFT JOIN은 모든 사용자와 그들의 주문(없으면 NULL)을 보여줍니다.', '2025-01-04 23:38:30', NULL),
    (11, '리버스 프록시는 클라이언트 요청을 백엔드 서버로 전달하고 응답을 다시 중계하는 방식으로, 보안, 로드 밸런싱, 캐싱 등에 유리합니다. 예시는 다음과 같습니다:

    ```nginx
    location /api/ {
        proxy_pass http://localhost:8080/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    ```
    이렇게 설정하면 /api 요청을 내부 애플리케이션 서버로 프록시합니다.', '2025-01-05 10:16:07', NULL),
    (12, 'TCP는 연결 지향적 프로토콜로 데이터의 순서와 신뢰성을 보장하지만, 상대적으로 느립니다. UDP는 비연결 지향이며 빠르지만 손실 가능성이 있습니다. TCP는 웹, 이메일, 파일 전송에, UDP는 스트리밍, 게임, DNS 요청 등 빠른 응답이 중요한 곳에 사용됩니다.', '2025-01-05 20:53:43', NULL),
    (13, '@Component는 클래스 자체에 선언해 자동으로 빈 등록되며, 주로 컴포넌트 스캔을 통해 감지됩니다. 반면 @Bean은 개발자가 메서드 단위로 반환값을 직접 빈으로 등록할 때 사용하며, 설정 클래스(@Configuration) 내부에 정의됩니다. 외부 라이브러리의 객체를 빈으로 등록할 때 주로 @Bean을 사용합니다.', '2025-01-06 07:31:20', NULL),
    (14, 'ElasticSearch는 JSON 기반의 문서 저장 및 검색 시스템으로, 인덱스(Index)는 논리적 데이터 집합이고, 도큐먼트(Document)는 실제 데이터 단위입니다. 인덱스는 내부적으로 여러 샤드(Shard)로 분할되며, 검색 시 샤드에 병렬 쿼리가 실행되고 결과를 통합합니다. 분산 구조로 인해 고가용성과 확장성이 뛰어나며, 텍스트 분석기(Analyzer)를 통해 역색인 방식으로 검색을 수행합니다.', '2025-01-06 18:08:57', NULL),
    (15, 'JWT는 `Header.Payload.Signature`의 세 부분으로 구성됩니다. Header에는 타입과 알고리즘 정보가, Payload에는 사용자 정보(Claims)가 담깁니다. Signature는 Header와 Payload를 비밀 키로 서명한 값으로, 토큰이 위조되지 않았음을 검증합니다. 서버는 Signature를 다시 계산해 일치 여부를 확인함으로써 토큰의 무결성을 확인합니다.', '2025-01-07 04:46:34', NULL),
    (16, '인덱스는 조회 성능을 크게 높여주지만, 과도한 인덱스는 쓰기 성능을 저하시키고 디스크 공간도 낭비합니다. 자주 검색되거나 JOIN, WHERE, ORDER BY에 자주 등장하는 컬럼에 적용하는 것이 효과적입니다. 다중 컬럼 인덱스의 경우 컬럼 순서에 따라 활용도가 달라지므로 주의가 필요하며, 실제 실행 계획(EXPLAIN)을 보고 검증하는 것이 좋습니다.', '2025-01-07 15:24:10', NULL),
    (17, '트리 쉐이킹은 사용되지 않는 코드(dead code)를 제거하여 번들 크기를 줄이는 기법입니다. ES Module 기반의 정적 분석이 가능할 때 작동하며, 불필요한 유틸 함수나 라이브러리 일부만 사용하는 경우 번들 용량을 최적화할 수 있습니다. side-effect가 있는 모듈은 제대로 제거되지 않을 수 있으므로 `sideEffects: false` 설정을 통해 안전하게 적용할 수 있습니다.', '2025-01-08 02:01:47', NULL),
    (18, '기본 스코프는 singleton이며, 컨테이너 당 하나의 인스턴스를 공유합니다. prototype은 요청마다 새 객체가 생성됩니다. 웹 환경에서는 request, session, application 스코프도 사용됩니다. 예를 들어 request는 HTTP 요청마다 빈을 생성하고, session은 사용자 세션마다 하나의 빈을 유지합니다.', '2025-01-08 12:39:24', NULL),
    (19, 'OSI 7계층은 응용, 표현, 세션, 전송, 네트워크, 데이터링크, 물리 계층으로 나뉘며, 추상화된 통신 계층을 설명합니다. HTTP 요청은 응용 계층(Application Layer)에서 시작되며, 전송 계층에서는 TCP로 패킷을 분할하고, 네트워크 계층에서 IP로 주소를 설정하며, 데이터링크 및 물리 계층을 통해 실제 전송됩니다. 반대 방향으로 응답도 동일한 계층을 역순으로 거쳐 도달합니다.', '2025-01-08 23:17:00', NULL),
    (20, '대표적으로 Filebeat → Logstash → Elasticsearch → Kibana(ELK 스택)으로 구성됩니다. Filebeat는 로그 파일을 수집하고, Logstash는 필터링과 파싱을 담당합니다. Elasticsearch는 검색 및 저장, Kibana는 대시보드 형태로 시각화를 제공합니다. 각 단계의 장애 전파를 막기 위해 큐(Kafka, Redis 등)를 중간에 넣기도 하며, 보안과 성능을 고려해 비동기 전송 구조를 권장합니다.', '2025-01-09 09:54:37', NULL),
    (21, '볼륨은 Docker가 관리하는 데이터 저장소로, 컨테이너 간 데이터 공유와 백업에 유리하며, 컨테이너 삭제와 무관하게 유지됩니다. 바인드 마운트는 호스트의 특정 디렉토리를 직접 마운트하며, 개발 환경에서 코드 변경을 실시간 반영할 때 유용합니다. 일반적으로 운영 환경에서는 볼륨이 권장됩니다.', '2025-01-09 20:32:14', NULL),
    (22, 'Stream API는 선언형 코드 스타일을 통해 가독성과 생산성을 높이고, 병렬 처리도 간단하게 구현할 수 있습니다. 그러나 중간 연산이 지연(lazy)되며 디버깅이 어려울 수 있고, 상태를 변경하는 연산은 지양해야 합니다. 주로 컬렉션 데이터를 필터링, 매핑, 집계할 때 사용됩니다.', '2025-01-10 07:09:51', NULL),
    (23, 'JWT는 로컬 스토리지보다는 HTTPOnly 쿠키에 저장하는 것이 더 안전합니다. 또한, 토큰 만료 시간을 짧게 설정하고, Refresh Token을 별도로 분리해 관리하며, 토큰 재사용 탐지 시스템도 구축할 수 있습니다. TLS를 통한 암호화 전송은 기본이며, 클라이언트 측 XSS 방지와 함께 CSP 설정도 중요합니다.', '2025-01-10 17:47:27', NULL),
    (24, '@EnableAutoConfiguration 어노테이션이 META-INF/spring.factories 파일에 정의된 설정 클래스를 기반으로 동작합니다. 조건부 빈 등록을 위해 @Conditional 계열 어노테이션이 사용되며, 특정 자동 구성을 끄려면 `spring.autoconfigure.exclude` 설정을 사용하거나 @SpringBootApplication의 exclude 속성을 지정할 수 있습니다.', '2025-01-11 04:25:04', NULL),
    (25, 'HTTP Keep-Alive는 하나의 TCP 연결을 통해 여러 HTTP 요청/응답을 처리할 수 있게 해주는 기능입니다. 이를 통해 매 요청마다 연결을 재설정하는 오버헤드를 줄이고, 네트워크 효율성을 높이며 응답 속도도 개선할 수 있습니다. 대부분의 웹 서버와 브라우저는 기본적으로 이 기능을 지원합니다.', '2025-01-11 15:02:41', NULL),
    (26, '영속성 컨텍스트는 엔티티 객체를 관리하는 JPA의 핵심 개념으로, 동일 트랜잭션 내에서 같은 엔티티를 공유하도록 1차 캐시를 제공합니다. 변경 감지는 트랜잭션 종료 시점에 엔티티 상태를 스냅샷과 비교하여 변경된 필드를 찾아 자동으로 UPDATE 쿼리를 생성합니다. 이는 dirty checking이라고도 하며, 명시적으로 save()를 호출하지 않아도 변경 내용을 반영할 수 있습니다.', '2025-01-12 01:40:17', NULL),
    (27, 'Redis는 String, Hash, List, Set, Sorted Set 등 다양한 구조를 지원합니다. 실무에서는 접근 빈도가 높은 데이터를 캐시하고, TTL(Time To Live)을 설정하여 메모리 과부하를 방지합니다. 데이터 정합성이 중요하지 않은 경우에는 write-through 또는 lazy caching 전략을, 정합성이 중요한 경우에는 캐시 무효화 정책(eviction, expire)을 적극적으로 활용합니다.', '2025-01-12 12:17:54', NULL),
    (28, '연결 설정은 SYN → SYN-ACK → ACK의 3단계를 거치며, 클라이언트와 서버가 모두 통신 가능함을 확인합니다. 연결 종료는 FIN → ACK → FIN → ACK의 4단계로 진행되며, 송수신이 모두 완료된 후에 자원을 해제합니다. 종료 시 TIME_WAIT 상태가 유지되어 중복된 세그먼트로 인한 문제를 방지합니다.', '2025-01-12 22:55:31', NULL),
    (29, 'CSR은 브라우저에서 JS가 렌더링을 처리하며, 초기 로딩이 느리지만 이후 사용자 경험은 부드럽습니다. SPA에 적합합니다. SSR은 서버에서 HTML을 렌더링해 초기 응답 속도가 빠르며, 검색 엔진 최적화(SEO)에 유리합니다. 블로그나 마케팅 페이지처럼 초기 로딩이 중요한 곳에 적합합니다.', '2025-01-13 09:33:08', NULL),
    (30, '@ControllerAdvice는 전역 예외 처리기를 정의할 수 있는 애노테이션으로, 특정 패키지나 모든 컨트롤러의 예외를 가로채 처리할 수 있습니다. @ExceptionHandler를 통해 예외 타입별로 로직을 분기할 수 있고, 일관된 에러 응답 구조를 정의할 수 있습니다. 응답 상태 코드도 @ResponseStatus 또는 ResponseEntity로 명시적으로 설정 가능합니다.', '2025-01-13 20:10:44', NULL),
    (31, '포워드 프록시는 클라이언트가 직접 접근할 수 없는 서버의 리소스를 요청할 때 중개 역할을 하며, 주로 내부 사용자 익명화나 필터링 목적에 사용됩니다. 반면 리버스 프록시는 클라이언트 요청을 받아 실제 서버로 전달하고, 응답을 대신 반환하는 구조로 로드 밸런싱, SSL 종료, 캐싱 등에 활용됩니다. Nginx는 대표적인 리버스 프록시입니다.', '2025-01-14 06:48:21', NULL),
    (32, 'fetch join은 JPQL에서 join fetch 구문을 통해 연관 엔티티를 한 번에 조회하는 방식이며, SQL 레벨에서 조인이 일어납니다. 반면 @EntityGraph는 메서드 레벨에서 선언적으로 로딩 전략을 제어할 수 있으며, 복잡한 쿼리 없이 fetch 설정을 분리할 수 있다는 장점이 있습니다. EntityGraph는 재사용성이 높고 JPQL을 건드리지 않아도 된다는 차이가 있습니다.', '2025-01-14 17:25:58', NULL),
    (33, '대표적인 전파 속성으로는 REQUIRED(기본), REQUIRES_NEW, NESTED, SUPPORTS 등이 있습니다. REQUIRED는 기존 트랜잭션이 있으면 참여하고 없으면 새로 생성합니다. REQUIRES_NEW는 항상 새로운 트랜잭션을 만들고, 기존 트랜잭션은 일시 정지됩니다. NESTED는 기존 트랜잭션 내부에서 savepoint를 사용해 롤백 범위를 제한할 수 있습니다. 상황에 따라 트랜잭션 경계를 명확히 설정할 수 있습니다.', '2025-01-15 04:03:34', NULL),
    (34, 'OAuth 2.0은 클라이언트가 인증 서버로부터 인가 코드를 받아 액세스 토큰을 발급받는 구조입니다. 액세스 토큰이 만료된 경우, 사용자는 다시 로그인하지 않고 Refresh Token을 사용해 새로운 액세스 토큰을 발급받을 수 있습니다. Refresh Token은 보통 저장소에 안전하게 보관되며, 인증 서버에서 유효성 검사를 통해 재발급을 진행합니다.', '2025-01-15 14:41:11', NULL),
    (35, '로컬에서 HTTPS를 적용하려면 OpenSSL을 사용해 자체 서명된 인증서를 생성할 수 있습니다. 예: `openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365` 명령으로 인증서와 키를 만들고, 개발 서버 설정(Nginx, Spring Boot 등)에 이를 적용합니다. 브라우저에서는 신뢰되지 않지만, 개발 테스트에는 충분히 활용 가능합니다.', '2025-01-16 01:18:48', NULL),
    (36, 'InnoDB는 트랜잭션, 외래 키, MVCC를 지원하는 ACID 준수 엔진이며, MyISAM은 경량화된 읽기 성능에 초점이 맞춰져 있습니다. InnoDB는 row-level locking을 지원해 동시성이 높고, MyISAM은 table-level locking으로 병렬 처리가 불리합니다. 일반적으로 InnoDB는 데이터 무결성과 안정성이 중요한 서비스에 적합합니다.', '2025-01-16 11:56:25', NULL),
    (37, '스프링 AOP는 프록시 기반의 AOP로, 런타임에 프록시 객체가 실제 객체를 감싸면서 메서드 호출 전후에 공통 기능을 삽입합니다. 실무에서는 트랜잭션 처리, 로깅, 권한 체크, 메서드 실행 시간 측정 등에 사용됩니다. 스프링은 기본적으로 JDK 동적 프록시와 CGLIB을 통해 AOP를 구현하며, AspectJ를 이용하면 컴파일 타임 또는 로드 타임 위빙도 가능합니다.', '2025-01-16 22:34:01', NULL),
    (38, 'HTML 파싱 → DOM 트리 생성, CSS 파싱 → CSSOM 트리 생성 → DOM + CSSOM으로 렌더 트리 구성 → 레이아웃 계산 → 페인팅 → 컴포지팅 순으로 진행됩니다. 이 중 레이아웃과 페인팅은 리플로우/리페인트 성능 이슈와 직결되므로 성능 최적화의 핵심 포인트입니다.', '2025-01-17 09:11:38', NULL),
    (39, 'API Gateway는 클라이언트와 마이크로서비스 사이의 단일 진입점으로, 라우팅, 인증/인가, 로깅, 속도 제한, 캐싱 등을 수행합니다. 모든 외부 요청이 게이트웨이를 거쳐 가므로 보안과 정책 적용의 중심 역할을 하며, 클라이언트 입장에서 여러 서비스 호출을 통합해주는 BFF 역할도 수행할 수 있습니다.', '2025-01-17 19:49:15', NULL),
    (40, 'CORS는 다른 출처(origin)의 리소스를 요청할 수 있도록 서버에서 허용하는 보안 정책입니다. 기본적으로 브라우저는 보안상의 이유로 다른 출처의 요청을 차단합니다. 서버는 응답 헤더에 `Access-Control-Allow-Origin` 등을 포함시켜 허용할 수 있습니다. Spring에서는 WebMvcConfigurer의 addCorsMappings() 메서드로 설정할 수 있습니다.', '2025-01-18 06:26:51', NULL),
    (41, 'Spring Security는 여러 개의 보안 필터로 구성된 FilterChainProxy를 통해 요청을 처리합니다. 인증은 UsernamePasswordAuthenticationFilter 등에서 처리되고, 인증 정보는 SecurityContext에 저장됩니다. 인가는 FilterSecurityInterceptor에서 이루어지며, 접근 권한이 있는지 확인합니다. 이 모든 필터는 DispatcherServlet 이전에 동작합니다.', '2025-01-18 17:04:28', NULL),
    (42, '@PostConstruct는 애노테이션 기반이고, InitializingBean은 인터페이스 기반입니다. 전자는 외부 라이브러리 클래스에도 사용할 수 있지만, 후자는 구현체에만 가능합니다. @PostConstruct는 메서드 하나에 선언만 하면 되고, InitializingBean은 afterPropertiesSet() 메서드를 오버라이딩해야 합니다.', '2025-01-19 03:42:05', NULL),
    (43, '샤딩은 수평적 분산으로, 데이터를 여러 DB 인스턴스에 나눠 저장합니다. 반면 파티셔닝은 하나의 DB 내에서 데이터를 논리적으로 구분합니다. 샤딩은 서비스 확장을 위해 사용되며, 파티셔닝은 주로 쿼리 성능 향상이나 관리 편의를 위해 사용됩니다. 샤딩은 운영 복잡성이 더 크지만, 대규모 분산 환경에서 유리합니다.', '2025-01-19 14:19:42', NULL),
    (44, '사용자는 클라이언트를 통해 인증 요청을 보내면, 인증 서버는 인가 코드를 발급합니다. 클라이언트는 이 코드를 가지고 다시 인증 서버에 접근해 액세스 토큰을 요청하고, 서버는 클라이언트의 인증 정보와 함께 코드를 검증한 후 토큰을 발급합니다. 이 방식은 보안상 가장 강력하며, 서버 간 통신으로 토큰을 주고받기 때문에 클라이언트 측 노출이 없습니다.', '2025-01-20 00:57:18', NULL),
    (45, 'Debounce는 이벤트가 연속으로 발생하면 일정 시간 동안 이벤트를 지연시키고, 가장 마지막 이벤트만 실행합니다. 주로 검색 자동완성 등에 사용됩니다. Throttle은 일정 주기마다 이벤트를 한 번씩만 실행하며, 스크롤 이벤트나 윈도우 리사이즈와 같이 자주 발생하는 이벤트에 적합합니다.', '2025-01-20 11:34:55', NULL),
    (46, '로그 레벨은 TRACE < DEBUG < INFO < WARN < ERROR 순으로 심각도를 나타냅니다. TRACE는 상세한 내부 흐름, DEBUG는 디버깅 목적, INFO는 상태 변화나 주요 흐름, WARN은 예외는 아니지만 문제의 가능성이 있는 상황, ERROR는 예외나 심각한 오류를 나타냅니다. 운영 환경에서는 INFO 이상만 출력하고, 개발 환경에서는 DEBUG 이상을 출력하는 것이 일반적입니다.', '2025-01-20 22:12:32', NULL),
    (47, 'persist()는 JPA 표준 EntityManager의 메서드로, 새 엔티티만 영속화할 수 있습니다. 이미 존재하는 식별자가 있는 엔티티에는 IllegalArgumentException이 발생합니다. 반면 save()는 Spring Data JPA에서 제공하는 메서드로, 새 엔티티는 persist, 이미 존재하는 엔티티는 merge 동작을 합니다. 결과적으로 save()는 범용적으로 편리하지만, 의도치 않은 merge가 발생할 수 있어 주의가 필요합니다.', '2025-01-21 08:50:08', NULL),
    (48, 'Prometheus와 Grafana를 활용해 메트릭 수집과 시각화를 구성하고, Alertmanager를 통해 슬랙이나 이메일로 알림을 받을 수 있습니다. 애플리케이션 로그는 Filebeat → Logstash → Elasticsearch → Kibana(ELK)로 수집하고 분석합니다. 또한, 서버 상태와 API 응답시간 등을 기준으로 SLA를 정하고 임계값 기반의 알림을 설정하는 것이 중요합니다.', '2025-01-21 19:27:45', NULL),
    (49, '2xx는 요청이 정상적으로 처리되었음을 의미하며, 대표적으로 200 OK, 201 Created 등이 있습니다. 4xx는 클라이언트 오류로, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found 등이 있습니다. 5xx는 서버 측 오류로, 500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable 등이 있습니다. 각각의 코드는 원인 파악과 디버깅에 중요한 정보를 제공합니다.', '2025-01-22 06:05:22', NULL),
    (50, '@ConfigurationProperties는 application.yml의 계층 구조 설정 값을 객체 단위로 바인딩할 수 있게 해주는 기능입니다. 여러 프로퍼티를 하나의 클래스로 묶어 관리할 수 있어 유지보수가 용이하고, 타입 안정성도 높습니다. 반면 @Value는 개별 값을 주입할 수 있지만, 복잡한 구조에서는 불편하고 하드코딩 위험이 있습니다.', '2025-01-22 16:42:59', NULL),
    (51, '@RequestParam은 쿼리 파라미터 또는 HTML form 데이터에서 값을 추출하며, ?name=value 형태로 전달됩니다. @PathVariable은 URL 경로의 일부를 변수로 추출할 때 사용됩니다. 예: `/user?id=1`에서는 @RequestParam 사용, `/user/1`에서는 @PathVariable을 사용합니다.', '2025-01-23 03:20:35', NULL),
    (52, 'cascade는 부모 엔티티의 작업(persist, remove 등)을 연관된 자식 엔티티에 자동으로 전파하는 설정입니다. 예를 들어 부모를 저장할 때 자식도 함께 저장되도록 하려면 CascadeType.PERSIST를 사용합니다. 하지만 잘못 설정하면 예기치 않게 대량 삭제나 저장이 발생할 수 있어, 관계 방향성과 생명주기를 명확히 이해하고 설정해야 합니다.', '2025-01-23 13:58:12', NULL),
    (53, 'SPA는 클라이언트 라우팅을 통해 페이지를 전환하며, 전체 페이지를 다시 로드하지 않고 필요한 컴포넌트만 교체합니다. react-router 등의 라이브러리를 사용하며, 상태 관리는 useState, useContext, Redux, Recoil 등의 도구를 통해 전역 또는 로컬 상태를 관리합니다. 비동기 데이터는 React Query나 SWR로 처리하기도 합니다.', '2025-01-24 00:35:49', NULL),
    (54, 'Redis pub/sub은 발행자(Publisher)가 메시지를 채널에 발행하면, 구독자(Subscriber)가 해당 채널을 통해 메시지를 수신하는 방식입니다. 메시지는 휘발성이며 저장되지 않습니다. 실무에서는 채팅 시스템, 알림 전송, 실시간 로그 모니터링 등에 사용되며, 메시지 유실이 치명적인 경우 Kafka와 같은 메시지 큐를 함께 사용하기도 합니다.', '2025-01-24 11:13:25', NULL),
    (55, 'Cache-Control은 max-age, no-store, no-cache, public/private 등 다양한 옵션으로 캐시 정책을 정의합니다. 예: `max-age=3600`은 1시간 동안 캐시 유효, `no-store`는 아예 저장하지 않음, `no-cache`는 항상 재검증함을 의미합니다. 민감한 데이터는 캐싱을 피하고, 정적 자원은 캐시를 적극 활용하되, 버전 관리를 통해 업데이트를 강제하는 전략이 필요합니다.', '2025-01-24 21:51:02', NULL),
    (56, '응답 속도를 높이기 위한 전략으로는 프록시 캐시(Nginx, CDN), 애플리케이션 캐시(Redis), DB 결과 캐시 등이 있습니다. 자주 변하지 않는 데이터는 TTL을 설정해 캐시하고, 요청 키를 기준으로 데이터를 캐싱하는 key-value 구조를 사용합니다. 캐시 무효화 정책도 함께 고려해야 하며, 예측 가능한 요청은 선제적으로 캐싱하는 프리패칭도 사용할 수 있습니다.', '2025-01-25 08:28:39', NULL),
    (57, '세션 방식은 서버가 사용자 상태를 메모리 또는 DB에 저장하고 세션 ID를 클라이언트에 보냅니다. JWT는 클라이언트가 상태 정보를 포함한 토큰을 저장하며, 서버는 상태를 저장하지 않아 확장성이 뛰어납니다. JWT는 서버 간 인증 공유에 유리하지만, 토큰 무효화가 어렵고 탈취 시 위험합니다. 세션은 제어가 쉽지만 서버 부하가 늘어납니다.', '2025-01-25 19:06:16', NULL),
    (58, 'React에서는 memo, useMemo, useCallback 등의 훅을 활용해 불필요한 렌더링을 방지할 수 있습니다. 또한, key 값을 안정적으로 부여하고, 무거운 연산은 useMemo로 메모이제이션하며, props 변경이 적은 하위 컴포넌트는 React.memo로 감쌉니다. Virtualized List 사용, 코드 스플리팅도 성능 최적화에 도움됩니다.', '2025-01-26 05:43:52', NULL),
    (59, 'HTTP는 데이터를 암호화하지 않고 전송하는 반면, HTTPS는 SSL/TLS를 이용해 데이터를 암호화합니다. 이 과정을 통해 중간자 공격, 도청, 위조를 방지할 수 있습니다. TLS는 대칭키 기반의 암호화를 제공하며, 대칭키 전달은 공개키 암호화 방식으로 보장됩니다. 또한, 인증서를 통해 서버 신원을 검증합니다.', '2025-01-26 16:21:29', NULL),
    (60, 'RestTemplate은 동기 방식으로 요청을 처리하며, 간단한 구조로 기존 스프링 애플리케이션에 많이 사용됩니다. 반면 WebClient는 리액티브 프로그래밍 모델에 기반해 비동기, 논블로킹 방식으로 동작하며, 대규모 처리나 성능 최적화가 필요한 환경에 적합합니다. Spring 5 이후 WebClient 사용이 권장됩니다.', '2025-01-27 02:59:06', NULL),
    (61, '트랜잭션은 데이터베이스의 상태를 변화시키는 작업의 논리적 단위로, 원자성, 일관성, 고립성, 지속성(ACID)을 만족해야 합니다. COMMIT은 현재 트랜잭션의 변경 내용을 확정하고 저장하며, ROLLBACK은 트랜잭션 내 모든 변경 사항을 취소하여 이전 상태로 되돌립니다. 트랜잭션을 지원하는 InnoDB 엔진에서 사용됩니다.', '2025-01-27 13:36:42', NULL),
    (62, '@Value는 개별 설정값을 바로 주입할 수 있어 간단하지만, 복잡한 구조나 다수의 값을 주입할 때는 불편하고 유지보수가 어렵습니다. 반면 @ConfigurationProperties는 계층적 구조를 객체 단위로 주입할 수 있어 타입 안정성과 재사용성이 높습니다. 대규모 설정을 다룰 때는 @ConfigurationProperties가 적합합니다.', '2025-01-28 00:14:19', NULL),
    (63, 'JWT는 Header, Payload, Signature로 구성됩니다. Header에는 토큰 타입과 서명 알고리즘 정보가 담기고, Payload에는 사용자 정보와 만료 시간 같은 클레임이 들어갑니다. Signature는 Header와 Payload를 비밀키로 서명한 값으로, 토큰이 위조되지 않았음을 검증하는 데 사용됩니다.', '2025-01-28 10:51:56', NULL),
    (64, '전역 상태는 여러 컴포넌트에서 공유되어야 하는 로그인 정보, 테마 설정, 장바구니 데이터 등에서 필요합니다. Context API는 간단한 전역 상태에 적합하며, 상태가 복잡해지면 Redux, Recoil, Zustand 등의 상태 관리 도구를 사용할 수 있습니다. React Query는 서버 상태를 전역처럼 다루는 데 유용합니다.', '2025-01-28 21:29:33', NULL),
    (65, 'CI(Continuous Integration)는 코드 변경 사항을 자주 병합하고 자동으로 빌드 및 테스트하는 과정을 의미합니다. CD는 Continuous Delivery(자동 배포 준비) 또는 Continuous Deployment(자동 배포 실행)를 의미하며, 변경된 코드를 빠르고 안정적으로 사용자에게 전달하는 것을 목표로 합니다.', '2025-01-29 08:07:09', NULL),
    (66, '정규화는 데이터 중복을 제거하고, 데이터 무결성을 보장하기 위해 테이블을 구조화하는 과정입니다. 제1정규형(1NF), 제2정규형(2NF), 제3정규형(3NF) 등이 있으며 각 단계마다 종속성과 중복을 줄입니다. 장점은 저장 공간 절약과 이상현상 방지, 단점은 조인이 많아져 성능이 저하될 수 있다는 점입니다. 실무에서는 정규화와 비정규화를 적절히 혼합합니다.', '2025-01-29 18:44:46', NULL),
    (67, 'request 스코프는 HTTP 요청마다 새로운 빈 인스턴스를 생성하고, session 스코프는 사용자 세션마다 하나의 빈을 유지합니다. 일반 싱글톤 빈에서 이 스코프의 빈을 주입받으려면 proxyMode를 설정하거나 ObjectProvider를 사용해야 합니다. 잘못 사용하면 스레드 간 공유 문제나 메모리 누수가 발생할 수 있으므로 주의가 필요합니다.', '2025-01-30 05:22:23', NULL),
    (68, '쿠키는 클라이언트에 저장되고, 세션은 서버에 저장되며 클라이언트는 세션 ID만 쿠키를 통해 전달합니다. 쿠키는 노출되기 쉬우므로 민감한 정보는 저장하지 않고, HttpOnly, Secure, SameSite 설정으로 보안을 강화합니다. 세션은 서버 메모리를 사용하므로 스케일링 시 분산 세션 관리가 필요합니다.', '2025-01-30 16:00:00', NULL),
    (69, '코드 분할은 초기 번들 크기를 줄여 페이지 로딩 속도를 개선하기 위해 사용됩니다. React에서는 React.lazy와 Suspense를 활용해 컴포넌트 단위로 동적 로딩을 구현할 수 있으며, webpack의 dynamic import()도 함께 활용됩니다. 또한, 라우트 기반 분할이나 조건부 로딩으로 UX를 최적화할 수 있습니다.', '2025-01-31 02:37:36', NULL),
    (70, 'CDN은 사용자와 가까운 위치의 엣지 서버에서 정적 자원을 제공함으로써 응답 속도와 안정성을 높여줍니다. 캐시 갱신을 위해선 파일명에 해시값을 붙이거나, Cache-Control 헤더를 활용해 만료 시간을 설정합니다. 버전 관리와 캐시 무효화 정책을 함께 설계해야 예상치 못한 오래된 리소스가 전달되는 문제를 방지할 수 있습니다.', '2025-01-31 13:15:13', NULL),
    (71, '인터페이스는 구현을 가지지 않는 계약이며, 다중 구현이 가능합니다. 추상 클래스는 공통 구현을 포함할 수 있고 단일 상속만 가능합니다. 공통 로직이 있다면 추상 클래스, 역할 중심의 설계라면 인터페이스가 적합합니다. Java 8 이후 인터페이스도 default 메서드로 일부 구현이 가능하지만, 상태(필드)는 가질 수 없습니다.', '2025-01-31 23:52:50', NULL),
    (72, 'merge()는 준영속 상태의 엔티티를 영속성 컨텍스트에 다시 병합하는 데 사용됩니다. 기존 DB에 있는 값과 병합된 새 객체를 반환하며, 원래 객체는 여전히 준영속 상태입니다. 실수로 잘못된 데이터가 덮어씌워질 수 있으므로, 반드시 병합 전 데이터를 검증해야 하며, 가능한 persist() 사용을 우선 고려하는 것이 안전합니다.', '2025-02-01 10:30:26', NULL),
    (73, 'Filter는 서블릿 스펙 기반이며 DispatcherServlet 이전에 동작합니다. 주로 인증, 로깅, CORS 등 공통 처리에 사용됩니다. Interceptor는 스프링 MVC에 종속되며 컨트롤러 호출 전후에 동작합니다. 요청 전후 처리, 권한 검사, 모델 변경 등에 유용합니다. 더 세밀한 스프링 컨텍스트 접근이 필요하면 Interceptor를 사용합니다.', '2025-02-01 21:08:03', NULL),
    (74, 'GET은 리소스 조회, POST는 리소스 생성, PUT은 전체 업데이트, PATCH는 일부 업데이트, DELETE는 리소스 삭제에 사용됩니다. GET은 안전하고 캐시가 가능하며, POST는 데이터 전송량 제한이 적고 멱등성이 없습니다. PUT과 DELETE는 멱등성 보장, PATCH는 부분 변경에 유리합니다.', '2025-02-02 07:45:40', NULL),
    (75, '의존성 배열은 useEffect가 언제 실행될지를 결정하는 기준입니다. 빈 배열이면 최초 1회, 배열에 있는 값이 변경되면 다시 실행됩니다. 잘못된 의존성 설정은 불필요한 재렌더링이나 업데이트 누락을 초래할 수 있습니다. 의존성 배열 생략 시 모든 렌더링마다 실행되어 성능 저하가 발생할 수 있습니다.', '2025-02-02 18:23:17', NULL),
    (76, 'GROUP BY는 특정 컬럼을 기준으로 집계 함수(SUM, COUNT 등)를 사용할 수 있도록 데이터를 그룹화합니다. HAVING은 GROUP BY로 집계된 결과에 조건을 걸 때 사용되며, WHERE은 집계 전 조건에 사용됩니다. 예를 들어, ''카테고리별 판매 수가 10건 이상''과 같은 조건을 HAVING으로 필터링합니다.', '2025-02-03 05:00:53', NULL),
    (77, '@ControllerAdvice와 @ExceptionHandler를 활용하여 특정 예외에 대한 응답 코드를 정의할 수 있습니다. 또한, ResponseStatusException을 직접 던지거나, 예외 클래스에 @ResponseStatus 애노테이션을 부여할 수도 있습니다. 이 방식으로 400, 404, 500 등 사용자 정의 예외에 맞는 상태 코드를 설정할 수 있습니다.', '2025-02-03 15:38:30', NULL),
    (78, 'key는 React가 각 요소를 식별할 수 있게 하여 효율적인 가상 DOM 비교를 가능하게 합니다. 고유하고 예측 가능한 값을 key로 지정해야 하며, index를 key로 사용하면 요소 순서 변경 시 불필요한 렌더링이나 상태 꼬임이 발생할 수 있습니다. 주로 데이터의 고유 ID를 key로 사용하는 것이 권장됩니다.', '2025-02-04 02:16:07', NULL),
    (79, 'Implicit Grant는 클라이언트가 브라우저를 통해 액세스 토큰을 직접 받는 방식으로, 빠르고 간단하지만 토큰이 URL 해시에 포함되어 노출되기 쉽습니다. 토큰 탈취 위험이 높고, 리프레시 토큰을 사용할 수 없어 장기 세션 유지에 불리합니다. 현재는 보안상의 이유로 거의 사용되지 않고, Authorization Code 방식이 권장됩니다.', '2025-02-04 12:53:43', NULL),
    (80, '동기 처리는 요청이 완료될 때까지 다음 작업을 기다리는 방식이고, 비동기는 요청과 응답이 분리되어 작업이 병렬로 진행됩니다. 예: 동기는 파일을 읽고 그 결과를 기다리는 방식, 비동기는 콜백이나 이벤트 루프를 통해 처리됩니다. REST API 호출 시 비동기 처리는 응답 속도 개선과 자원 활용 최적화에 유리합니다.', '2025-02-04 23:31:20', NULL),
    (81, '1) 같은 클래스 내부에서 메서드를 호출할 경우 프록시를 거치지 않아 적용되지 않습니다.
    2) private 메서드에는 적용되지 않습니다.
    3) 예외가 발생해도 CheckedException일 경우 rollback이 되지 않습니다.
    4) 클래스에 등록되지 않은 일반 객체에서 @Transactional을 사용할 경우 적용되지 않습니다.', '2025-02-05 10:08:57', NULL),
    (82, '인덱스는 조회 시 탐색 범위를 줄여 성능을 향상시킵니다. 하지만 데이터를 삽입하거나 수정할 때마다 인덱스도 함께 갱신되어야 하므로 부가적인 쓰기 작업이 필요합니다. 특히 다중 인덱스가 존재할 경우 성능 저하가 더 커지며, 잘못된 인덱스 설계는 오히려 성능을 악화시킬 수 있습니다.', '2025-02-05 20:46:34', NULL),
    (83, '1) Refresh Token을 사용해 자동으로 액세스 토큰을 재발급하고, 사용자는 로그인 상태를 유지합니다.
    2) 토큰 만료를 클라이언트에서 감지해 로그인 페이지로 리다이렉트하거나, 알림을 띄워 재로그인을 유도할 수 있습니다.
    사용자 불편을 최소화하면서 보안을 유지하는 것이 핵심입니다.', '2025-02-06 07:24:10', NULL),
    (84, 'Hydration은 서버에서 렌더링된 HTML을 클라이언트에서 React가 takeover하는 방식입니다.
    초기 화면은 SSR로 빠르게 보여주고, 이후 React가 DOM을 연결해 상호작용을 가능하게 만듭니다.
    이로 인해 초기 로딩 속도는 빠르면서도 SPA의 장점을 유지할 수 있습니다.
    Next.js 같은 프레임워크에서 사용됩니다.', '2025-02-06 18:01:47', NULL),
    (85, '1) 블루-그린 배포: 기존 서버와 새 서버를 병렬 운영하고, 트래픽을 전환함으로써 배포 중단 없이 전환합니다.
    2) 롤링 배포: 서버를 순차적으로 교체하며 전체를 점진적으로 업데이트합니다.
    3) Canary 배포: 소수 트래픽으로 배포를 테스트한 후 점진적으로 확장합니다.
    헬스 체크와 자동 롤백 설정이 필수입니다.', '2025-02-07 04:39:24', NULL),
    (86, 'Optional은 NullPointerException을 방지하고 명시적인 null 처리 흐름을 만들기 위해 사용됩니다. null 여부를 Optional로 감싸면서 값 유무를 안전하게 다룰 수 있습니다. 장점은 코드 가독성과 안정성 향상이며, 단점은 남용 시 불필요한 래핑과 복잡도를 높일 수 있다는 점입니다. 반환 값에 사용하는 것이 일반적이며, 필드에는 사용하지 않는 것이 권장됩니다.', '2025-02-07 15:17:00', NULL),
    (87, 'EAGER는 엔티티 로딩 시 연관 엔티티도 즉시 함께 로딩하며, LAZY는 실제 사용 시점에 쿼리를 실행합니다. 기본적으로 LAZY를 사용하는 것이 성능과 유연성 측면에서 유리하며, EAGER는 예상치 못한 조인으로 N+1 문제가 발생할 수 있습니다. 즉시 사용이 확실한 경우에만 EAGER를 고려해야 합니다.', '2025-02-08 01:54:37', NULL),
    (88, '1) props를 통해 유연하게 구성할 수 있도록 설계합니다.
    2) 상태를 최소화하고 상위에서 관리하도록 합니다.
    3) UI/로직 분리(Component vs Hook) 구조를 갖추고,
    4) children, render props, 컴포지션 패턴 등을 활용해 다양한 상황에 대응할 수 있도록 구성합니다.
    재사용성을 고려한 네이밍과 문서화도 중요합니다.', '2025-02-08 12:32:14', NULL),
    (89, 'TCP는 연결 지향적이며 신뢰성이 보장되며, 데이터 순서 보장과 오류 복구가 가능합니다.
    UDP는 비연결 지향이며 속도가 빠르지만 신뢰성이 없습니다.
    TCP는 웹, 이메일, 파일 전송 등에 사용되며, UDP는 영상 스트리밍, VoIP, 게임 등 빠른 전송이 필요한 곳에 적합합니다.', '2025-02-08 23:09:51', NULL),
    (90, '테스트 자동화는 배포 전 코드 품질을 검증하고 버그를 조기에 발견하기 위해 중요합니다.
    보통 코드 커밋 시 단위 테스트, 통합 테스트가 실행되며, Jenkins, GitHub Actions 등의 도구로 구성합니다.
    테스트 커버리지 도구(Jacoco 등)를 연동해 품질 기준을 설정하고, 실패 시 배포가 중단되도록 설정하는 것이 일반적입니다.', '2025-02-09 09:47:27', NULL),
    (91, 'RESTful URI는 명사 중심, 리소스 기반, 계층적 구조로 설계되어야 하며, 동사를 URI에 넣지 않아야 합니다. 예: `/users/1/orders`는 사용자 1의 주문 목록을 의미합니다. `/getUser`와 같은 동사 기반 URI는 안티패턴입니다. URI는 상태가 아니라 리소스를 표현하며, 일관성, 예측 가능성, 소문자 표기 등을 유지해야 합니다.', '2025-02-09 20:25:04', NULL),
    (92, '@MappedSuperclass는 공통 필드(예: id, createdAt 등)를 상속받는 엔티티에 주입하기 위한 상속 전용 클래스입니다. 데이터베이스 테이블로 매핑되지 않으며, 자식 클래스에서만 테이블이 생성됩니다. @Entity는 테이블과 매핑되어 직접 쿼리 대상이 되는 반면, @MappedSuperclass는 쿼리 대상이 아닙니다.', '2025-02-10 07:02:41', NULL),
    (93, '1) 서버 사이드 렌더링(SSR) 도입, Next.js와 같은 프레임워크 활용
    2) Pre-rendering(정적 사이트 생성) 적용
    3) React Helmet 등을 사용해 메타태그 관리
    4) 중요한 페이지만 선택적으로 SSR 적용
    5) Googlebot 등 크롤러에 대한 대응 방안 설정 등으로 SEO를 보완할 수 있습니다.', '2025-02-10 17:40:17', NULL),
    (94, 'gzip 압축은 HTML, CSS, JS 파일의 용량을 줄여 전송 속도를 개선하고, 사용자 응답 속도를 높입니다. Nginx 설정 파일에 `gzip on; gzip_types text/css application/javascript;` 등을 추가하면 사용할 수 있습니다. 텍스트 기반 자원에서 효과가 크며, 이미지에는 적용하지 않습니다.', '2025-02-11 04:17:54', NULL),
    (95, 'OAuth 2.0은 리소스 접근 권한을 위임하는 프레임워크이고, OpenID Connect는 OAuth 2.0 위에 인증 기능을 추가한 프로토콜입니다. OAuth는 ''누군가의 리소스를 대신 사용하기 위한 인증''이며, OpenID Connect는 ''사용자가 누구인지 증명하는 인증''입니다. OpenID Connect는 ID 토큰을 통해 사용자 정보까지 제공합니다.', '2025-02-11 14:55:31', NULL),
    (96, '영속성 컨텍스트는 동일한 트랜잭션 내에서 같은 엔티티를 여러 번 조회해도 DB를 재조회하지 않고 1차 캐시에 저장된 객체를 반환합니다. 이는 성능을 향상시키고, 동일성 보장을 가능하게 합니다. 하지만 트랜잭션이 길어지면 메모리를 많이 점유하고, 데이터 정합성 문제가 발생할 수 있어 적절한 범위 내에서 사용하는 것이 중요합니다.', '2025-02-12 01:33:08', NULL),
    (97, '@Async는 별도의 스레드에서 메서드를 실행하며, 반환값이 Future 또는 CompletableFuture일 수 있습니다.
    1) 같은 클래스 내 메서드 호출은 프록시를 통하지 않아 동작하지 않습니다.
    2) 비동기 메서드는 public 이어야 하며,
    3) 스레드 풀 설정을 고려하지 않으면 예상치 못한 동시성 문제나 성능 저하가 발생할 수 있습니다.', '2025-02-12 12:10:44', NULL),
    (98, '1) 코드 스플리팅으로 필요할 때만 JS를 로딩하고
    2) 이미지 lazy-loading 적용
    3) 중요한 HTML 콘텐츠는 SSR/Pre-rendering으로 대체
    4) 폰트, 아이콘, 썸네일 등의 리소스는 CDN 활용
    5) 트리 쉐이킹과 번들 최적화 설정(Webpack, Vite 등)을 통해 초기 번들 사이즈를 줄이는 것이 효과적입니다.', '2025-02-12 22:48:21', NULL),
    (99, '3계층 구조는 Presentation(컨트롤러), Business(서비스), Persistence(리포지토리)로 구성됩니다.
    Presentation은 사용자 요청을 받고 응답을 반환하며, Business는 핵심 비즈니스 로직을 처리합니다.
    Persistence는 DB와의 입출력을 담당합니다.
    이 구조는 책임 분리를 통해 유지보수성과 테스트 용이성을 향상시킵니다.', '2025-02-13 09:25:58', NULL),
    (100, 'Authorization Code는 서버 간 통신을 통한 보안성이 높은 방식으로, 대부분의 앱에서 권장됩니다.
    Implicit은 브라우저 기반 클라이언트에 사용되며 현재는 권장되지 않습니다.
    Password는 사용자 인증 정보를 직접 받기 때문에 보안상 위험하며, 신뢰된 앱에서만 사용됩니다.
    Client Credentials는 사용자 없이 서버 간 인증에 사용됩니다.', '2025-02-13 20:03:34', NULL),
    (101, '1) fetch join을 사용해 연관된 엔티티를 한 번의 쿼리로 조회
    2) @EntityGraph를 통해 JPQL 없이 페치 전략 지정
    3) batch size 설정으로 IN 쿼리 형태로 변경
    4) DTO로 필요한 데이터만 조회하는 방법
    이 외에도 쿼리 최적화와 설계 변경으로 문제를 해결할 수 있으며, 원인을 정확히 파악한 후 적용해야 합니다.', '2025-02-14 06:41:11', NULL),
    (102, '우선순위는 @Primary, @Qualifier, @Order, @Priority 등을 통해 제어할 수 있습니다.
    1) @Primary는 기본 후보로 지정되며,
    2) @Qualifier는 특정 이름의 빈을 명시적으로 주입할 수 있게 합니다.
    3) XML 설정에서는 `<primary>`나 `<bean name>`을 활용할 수도 있습니다.', '2025-02-14 17:18:48', NULL),
    (103, '상태 끌어올리기는 공통 부모 컴포넌트로 state를 이동시키고, 하위 컴포넌트들은 props를 통해 상태를 주고받는 구조입니다. 이를 통해 데이터 흐름이 단방향으로 유지되며, 컴포넌트 간 상태 동기화를 쉽게 구현할 수 있습니다.', '2025-02-15 03:56:25', NULL),
    (104, 'HSTS는 브라우저가 해당 도메인에 대해 항상 HTTPS를 사용하도록 강제하는 응답 헤더입니다.
    서버가 `Strict-Transport-Security` 헤더를 전송하면 브라우저는 이후 HTTP 요청을 자동으로 HTTPS로 전환합니다. 이를 통해 SSL stripping 공격을 방지하고, HTTPS로 안전하게 통신할 수 있도록 합니다.', '2025-02-15 14:34:01', NULL),
    (105, '1) PRIMARY KEY: 기본 키, 중복 불가 + NOT NULL
    2) FOREIGN KEY: 다른 테이블의 키와 연결
    3) UNIQUE: 중복 허용하지 않음
    4) NOT NULL: 반드시 값이 있어야 함
    5) CHECK: 조건을 만족해야 삽입 가능
    이러한 제약 조건은 잘못된 데이터를 미리 차단하는 역할을 합니다.', '2025-02-16 01:11:38', NULL),
    (106, 'mappedBy는 양방향 연관관계에서 주인이 아닌 쪽에서 사용하는 속성으로, 연관관계의 주인을 지정해줍니다. 주인이 아닌 쪽은 외래 키를 관리하지 않으며, mappedBy에는 연관관계 주인 엔티티의 필드명을 적습니다. 이를 통해 양쪽 모두 엔티티 상태는 유지하면서도 실제 DB에 반영되는 쿼리는 한쪽에서만 일어나게 됩니다.', '2025-02-16 11:49:15', NULL),
    (107, '@Scope는 Bean의 생성 범위를 지정하는 데 사용됩니다. 기본은 singleton이고, 이외에 prototype(요청마다 새로 생성), request(HTTP 요청마다), session(세션마다), application(애플리케이션 범위) 등이 있습니다. 주의할 점은 비싱글톤 스코프의 경우 상태 공유에 따른 예외나 메모리 문제에 유의해야 한다는 것입니다.', '2025-02-16 22:26:51', NULL),
    (108, 'React는 SyntheticEvent 시스템을 사용하여 이벤트를 루트에서 일괄 관리합니다. document 레벨에 이벤트 리스너를 등록하고, 이벤트가 발생하면 위임된 구조를 따라 이벤트가 전파됩니다. 이를 통해 많은 DOM 노드에 개별 이벤트를 붙이지 않아도 되며, 메모리와 성능을 절약할 수 있습니다.', '2025-02-17 09:04:28', NULL),
    (109, 'XSS는 악의적인 스크립트 코드를 웹 페이지에 삽입하여 사용자의 쿠키, 세션 등을 탈취하거나 조작하는 공격입니다. 방어 전략으로는
    1) 입력 값 검증,
    2) 출력 시 HTML Escape 처리,
    3) Content Security Policy(CSP) 설정,
    4) HTTPOnly, Secure 옵션 설정이 있으며,
    프레임워크 단에서 기본적으로 제공하는 XSS 방지 필터도 활용해야 합니다.', '2025-02-17 19:42:05', NULL),
    (110, '1) Round Robin: 순차적으로 서버에 요청 분배
    2) Least Connection: 현재 연결 수가 적은 서버에 분배
    3) IP Hash: 클라이언트 IP 기반으로 고정 서버 할당
    4) Weighted Round Robin: 서버 성능 비율에 따라 가중치 분배
    각 방식은 트래픽 특성, 세션 유지 필요 여부에 따라 선택됩니다.', '2025-02-18 06:19:42', NULL),
    (111, 'Cascade는 부모 엔티티의 영속/삭제 등의 작업이 자식에게 전파되도록 합니다. 예: CascadeType.ALL.
    OrphanRemoval은 부모와의 연관관계가 제거된 자식 엔티티를 자동으로 삭제합니다.
    둘의 차이는 Cascade는 ''작업 전파'', OrphanRemoval은 ''연결 해제 시 삭제''라는 점이며, 둘을 함께 사용할 수도 있습니다.', '2025-02-18 16:57:18', NULL),
    (112, 'Bean은 생성 → 의존성 주입 → 초기화 → 사용 → 소멸 단계를 거칩니다.
    초기화는 @PostConstruct, InitializingBean.afterPropertiesSet()을 통해,
    소멸은 @PreDestroy, DisposableBean.destroy()를 통해 처리할 수 있습니다.
    또한 XML 설정 시 init-method와 destroy-method로도 지정 가능합니다.', '2025-02-19 03:34:55', NULL),
    (113, 'Custom Hook은 use로 시작하는 함수로, 여러 컴포넌트에서 공통되는 로직(예: API 호출, 이벤트 핸들링, 상태 동기화 등)을 추출하여 재사용 가능하게 합니다.
    예: useFetch(url) 훅을 만들어 API 응답 데이터를 처리하는 로직을 공통화할 수 있습니다.
    내부에서 useEffect, useState 등 다른 훅을 사용할 수 있습니다.', '2025-02-19 14:12:32', NULL),
    (114, '브루트 포스는 가능한 모든 조합의 아이디/비밀번호를 시도하여 인증을 우회하는 공격입니다.
    방어 전략으로는
    1) 계정 잠금(Lockout),
    2) CAPTCHA 적용,
    3) 로그인 시도 제한(Rate Limiting),
    4) 2차 인증(2FA),
    5) 비밀번호 복잡성 정책 도입 등이 있습니다.
    서버 로그 모니터링도 중요합니다.', '2025-02-20 00:50:08', NULL),
    (115, 'RDB는 테이블-열 구조, 스키마 고정, JOIN 지원 등 정형 데이터에 강하며, 데이터 무결성과 복잡한 쿼리에 유리합니다.
    NoSQL은 문서(Document), 키-값, 컬럼형, 그래프 등 다양한 모델이 있으며, 스키마 유연성, 수평 확장성, 대용량 처리에 적합합니다.
    복잡한 트랜잭션이 많으면 RDB, 빠른 확장이 필요하면 NoSQL을 고려합니다.', '2025-02-20 11:27:45', NULL),
    (116, 'Dirty Checking은 JPA가 트랜잭션 종료 시점에 영속성 컨텍스트에 저장된 스냅샷과 현재 엔티티 상태를 비교하여 변경된 필드를 감지하고, 자동으로 UPDATE 쿼리를 생성하는 기능입니다. 개발자는 변경만 하면 되고 별도의 save() 호출 없이 반영되므로 유지보수가 쉬워집니다.', '2025-02-20 22:05:22', NULL),
    (117, 'BeanFactory는 DI의 가장 기본적인 컨테이너이며 Lazy 방식으로 Bean을 로딩합니다. ApplicationContext는 BeanFactory를 확장한 구조로, 메시지 리소스 처리, 이벤트 발행, AOP 연동, 국제화 등 다양한 기능을 제공합니다. 대부분의 실무에서는 ApplicationContext를 사용합니다.', '2025-02-21 08:42:59', NULL),
    (118, 'useMemo는 연산된 값을 메모이제이션하여 재계산을 방지하고, useCallback은 함수를 메모이제이션하여 함수 재생성을 방지합니다. useMemo는 값, useCallback은 함수 자체를 캐싱하며, 종속성 배열이 동일할 경우 이전 결과를 재사용합니다.', '2025-02-21 19:20:35', NULL),
    (119, 'CSRF는 사용자의 인증 정보를 악용해 의도치 않은 요청을 보내는 공격입니다.
    방어 전략으로는
    1) CSRF 토큰 사용,
    2) Referer 또는 Origin 검사,
    3) SameSite 쿠키 설정,
    4) 사용자 재인증 등이 있으며,
    POST/PUT 요청 등 상태 변경 요청에 대해 보호가 필요합니다.', '2025-02-22 05:58:12', NULL),
    (120, 'DDD의 핵심은 도메인을 모델링하고, 도메인 중심으로 소프트웨어를 구성하는 것입니다. 주요 개념으로는 Entity, Value Object, Aggregate, Repository, Service가 있으며, Bounded Context를 통해 도메인을 명확히 분리합니다. Ubiquitous Language를 통해 개발자와 도메인 전문가 간 의사소통을 일관되게 유지하는 것도 핵심입니다.', '2025-02-22 16:35:49', NULL),
    (121, '@Version은 낙관적 락을 적용하기 위한 필드에 붙으며, 엔티티가 수정될 때마다 해당 버전 필드가 자동 증가합니다.
    업데이트 시점에 DB에 저장된 버전과 현재 버전이 다르면 OptimisticLockException이 발생하여 충돌을 감지합니다.
    이 방식은 충돌 가능성이 낮은 시스템에 적합합니다.', '2025-02-23 03:13:25', NULL),
    (122, '@ComponentScan은 컴포넌트 클래스(@Component, @Service 등)를 자동으로 검색해 Bean으로 등록합니다.
    기본적으로 선언된 클래스의 패키지 하위부터 스캔하며, basePackages 속성을 지정하면 스캔 범위를 수동으로 조정할 수 있습니다.
    계층 구조가 복잡한 프로젝트에서 유용합니다.', '2025-02-23 13:51:02', NULL),
    (123, 'Controlled Component는 상태를 React에서 관리하며, value와 onChange를 props로 연결합니다.
    반면 Uncontrolled는 DOM 자체에서 값을 관리하며, ref를 통해 접근합니다.
    Controlled는 폼 검증이나 실시간 상태 반영이 필요한 경우,
    Uncontrolled는 초기 렌더링 이후 값이 크게 중요하지 않은 경우에 적합합니다.', '2025-02-24 00:28:39', NULL),
    (124, '예: `id='' OR ''1''=''1` 같은 입력으로 WHERE 조건을 항상 true로 만들어 전체 테이블을 조회하거나 삭제할 수 있습니다.
    방어 방법은
    1) PreparedStatement 사용,
    2) 입력값 유효성 검증,
    3) ORM 사용,
    4) 최소 권한의 DB 계정 운영,
    5) 에러 메시지 노출 금지 등이 있습니다.', '2025-02-24 11:06:16', NULL),
    (125, '모놀리식은 모든 기능이 하나의 애플리케이션으로 통합된 구조로, 배포와 테스트가 단순하지만 서비스 간 결합도가 높고 확장성이 떨어집니다.
    마이크로서비스는 기능별로 서비스를 나누어 독립 배포 및 확장이 가능하나,
    네트워크 통신, 데이터 일관성, 운영 복잡도 등 추가 고려 사항이 많습니다.', '2025-02-24 21:43:52', NULL),
    (126, 'Entity는 DB 테이블과 매핑되어 영속성 관리 대상이 되며, 비즈니스 로직도 일부 포함할 수 있습니다.
    반면 DTO는 계층 간 데이터 전달을 위한 객체로, 주로 컨트롤러와 뷰 또는 API 응답에 사용됩니다.
    DTO를 통해 Entity 외부 노출을 막고, 불필요한 데이터 전송과 변경 감지 부작용을 방지할 수 있습니다.', '2025-02-25 08:21:29', NULL),
    (127, '@Configuration은 설정 클래스를 정의하며, 내부에 @Bean 메서드를 선언하여 객체를 스프링 컨테이너에 등록합니다.
    @Bean은 개발자가 직접 제어할 수 없는 외부 라이브러리 객체나 복잡한 초기화가 필요한 객체를 빈으로 등록할 때 사용합니다.
    두 어노테이션은 함께 사용되며, 싱글톤 보장을 위해 proxyMode도 설정됩니다.', '2025-02-25 18:59:06', NULL),
    (128, '클린업 함수는 컴포넌트가 언마운트되거나 의존성 배열이 변경되어 useEffect가 다시 실행되기 직전에 호출됩니다.
    주로 타이머 해제, 이벤트 리스너 제거, 구독 해제 등에 사용됩니다.
    이 함수를 통해 리소스 누수나 의도치 않은 사이드 이펙트를 방지할 수 있습니다.', '2025-02-26 05:36:42', NULL),
    (129, '기밀성은 인가되지 않은 접근으로부터 데이터를 보호하는 것(예: 암호화),
    무결성은 데이터가 위변조되지 않았음을 보장하는 것(예: 해시, 서명),
    가용성은 필요한 사용자가 데이터를 사용할 수 있도록 하는 것(예: 서버 이중화, 장애 대응)을 의미합니다.', '2025-02-26 16:14:19', NULL),
    (130, '동기식(REST)은 요청-응답 기반으로 구현이 간단하고 직관적이지만, 한 서비스가 느려지면 전체 시스템에 영향을 줄 수 있습니다.
    비동기식(Message Queue)은 서비스 간 결합도를 낮추고 유연하게 확장 가능하지만, 메시지 브로커 운영 부담이 있으며 복잡한 오류 처리 로직이 필요할 수 있습니다.', '2025-02-27 02:51:56', NULL),
    (131, '지연 로딩(LAZY)은 실제 엔티티가 사용될 때 쿼리를 실행하고, 즉시 로딩(EAGER)은 엔티티 조회 시 연관 엔티티도 함께 조회합니다. LAZY는 성능 최적화에 유리하지만 초기 사용 시 N+1 문제가 발생할 수 있으며, EAGER는 초기 접근은 편리하지만 불필요한 데이터를 함께 가져올 수 있습니다. 대부분의 연관관계는 LAZY가 기본입니다.', '2025-02-27 13:29:33', NULL),
    (132, 'Pointcut은 어떤 메서드에 부가 기능을 적용할지 결정하는 표현식이며, Advice는 실제로 적용될 부가 기능(로직)입니다. 예를 들어 @Before는 메서드 실행 전 실행되는 Advice입니다. AOP는 프록시 객체를 통해 메서드 호출 시 Advice를 실행하며, Aspect로 여러 Pointcut과 Advice를 묶을 수 있습니다.', '2025-02-28 00:07:09', NULL),
    (133, '1) useEffect + useState를 조합해 직접 API 호출과 상태를 관리할 수 있습니다.
    2) useReducer로 상태 관리 분기를 명확히 할 수 있습니다.
    3) React Query, SWR 같은 라이브러리를 사용하면 캐싱, 리트라이, 로딩 처리 등이 자동화되어 편리합니다. 복잡한 상태가 많아지면 Redux-Toolkit도 사용할 수 있습니다.', '2025-02-28 10:44:46', NULL),
    (134, '1) 클라이언트가 서버에 Hello 메시지를 보내며 지원 프로토콜, 랜덤값 등을 전달
    2) 서버는 인증서와 함께 Hello 메시지 응답
    3) 클라이언트는 인증서 검증 후 프리마스터 시크릿을 서버의 공개키로 암호화해 전송
    4) 클라이언트와 서버는 동일한 세션 키를 계산해 암호화 통신을 시작합니다. 대칭키 암호화는 성능을, 공개키는 보안을 담당합니다.', '2025-02-28 21:22:23', NULL),
    (135, '서킷 브레이커 패턴은 외부 서비스 응답 실패가 누적되면 회로를 열어 요청을 차단하고, 잠시 후 재시도하도록 하여 시스템 전체 장애를 방지합니다. Netflix Hystrix, Resilience4j 같은 라이브러리를 사용합니다. 이와 함께 타임아웃 설정, 폴백 처리, 리트라이 정책을 함께 설계해야 안정적인 시스템을 유지할 수 있습니다.', '2025-03-01 08:00:00', NULL),
    (136, '@JoinColumn은 외래 키 컬럼의 이름을 명시할 때 사용합니다. 생략하면 JPA는 기본 네이밍 전략에 따라 컬럼명을 생성합니다. 이를 명시적으로 설정하지 않으면 컬럼명이 예상과 다를 수 있고, 여러 연관관계가 있을 경우 충돌이 발생할 수도 있습니다. 따라서 명확한 매핑을 위해 명시적으로 설정하는 것이 좋습니다.', '2025-03-01 18:37:36', NULL),
    (137, 'DispatcherServlet은 Front Controller로서 모든 HTTP 요청을 받아 처리 흐름을 제어합니다.
    요청 → HandlerMapping으로 컨트롤러 탐색 → HandlerAdapter 호출 → 컨트롤러 실행 → ModelAndView 반환 → ViewResolver로 뷰 탐색 → 뷰 렌더링 → 응답 순서로 동작합니다.
    필터와 인터셉터도 전후 처리에 관여합니다.', '2025-03-02 05:15:13', NULL),
    (138, 'key는 React가 각 컴포넌트를 고유하게 식별하여 효율적으로 렌더링할 수 있도록 도와줍니다.
    index를 key로 사용할 경우 요소 추가/삭제 시 잘못된 상태 전달이나 렌더링 오류가 발생할 수 있습니다. 가능한 고유 ID를 사용하는 것이 안전합니다.', '2025-03-02 15:52:50', NULL),
    (139, 'Access Token이 만료되었을 때 사용자는 다시 로그인하지 않고 Refresh Token을 통해 새로운 Access Token을 발급받을 수 있습니다.
    Refresh Token은 보안상의 이유로 서버에서 안전하게 저장되어야 하며, 탈취 위험에 대비한 재사용 제한, 만료 정책 등이 함께 적용되어야 합니다.', '2025-03-03 02:30:26', NULL),
    (140, '동기화 대상 데이터의 일관성 보장, 네트워크 지연, 장애 복구, 메시지 중복/유실 처리 등이 고려되어야 합니다.
    주로 이벤트 기반 아키텍처를 활용하며 Kafka, RabbitMQ 같은 메시지 브로커가 사용됩니다.
    이벤트 소싱, 트랜잭션 아웃박스 패턴 등도 자주 사용되는 방식입니다.', '2025-03-03 13:08:03', NULL),
    (141, 'JPQL은 객체 지향 쿼리 언어로 엔티티 기반으로 작성되며, 데이터베이스 독립성을 보장받을 수 있습니다.
    반면 Native Query는 SQL을 직접 작성하는 방식으로 복잡한 쿼리나 성능 최적화가 필요한 경우 사용합니다.
    JPQL은 유지보수성이 좋고 타입 안전하지만, 복잡한 쿼리 작성에는 한계가 있으며,
    Native Query는 데이터베이스 종속적이지만 강력한 표현력을 가집니다.', '2025-03-03 23:45:40', NULL),
    (142, '@Value는 간단한 설정 값을 필드에 바로 주입할 때 사용하며, SpEL을 활용할 수 있습니다.
    Environment는 프로그램 코드에서 동적으로 여러 설정 값을 읽거나 조건 분기 처리가 필요할 때 유용합니다.
    @Value는 정적인 속성에, Environment는 유연한 설정 처리에 적합합니다.', '2025-03-04 10:23:17', NULL),
    (143, 'React Portal은 부모 컴포넌트의 DOM 계층을 벗어나, 특정 DOM 노드에 자식 컴포넌트를 렌더링하는 기능입니다.
    ReactDOM.createPortal를 사용하여 구현하며, 모달, 드롭다운, 툴팁 등 레이아웃에 제약을 받지 않는 UI를 구성할 때 사용됩니다.', '2025-03-04 21:00:53', NULL),
    (144, '인증은 사용자가 누구인지 확인하는 과정이며, 예: 로그인.
    인가는 인증된 사용자가 어떤 자원에 접근할 수 있는지를 결정하는 권한 부여 과정입니다.
    인증이 선행되어야 인가가 이루어지며, 각각의 책임이 명확히 분리되어야 합니다.', '2025-03-05 07:38:30', NULL),
    (145, 'API 게이트웨이는 외부 트래픽을 수신하고 인증, 라우팅, 속도 제한 등을 처리합니다.
    서비스 메시는 마이크로서비스 간 내부 통신을 관리하며, 서비스 디스커버리, 트래픽 제어, 보안, 관측성을 담당합니다.
    API 게이트웨이는 진입점, 서비스 메시는 내부 통신 제어에 초점을 둡니다.', '2025-03-05 18:16:07', NULL),
    (146, 'fetch join은 연관된 엔티티를 함께 조회하여 N+1 문제를 해결하는 JPQL 문법입니다. join fetch를 사용하면 연관된 데이터를 한 번의 쿼리로 가져올 수 있습니다. 하지만 컬렉션을 여러 개 fetch join하면 중복 데이터가 생기고, 페이징 처리에 문제가 발생할 수 있으므로 필요한 상황에서만 신중하게 사용해야 합니다.', '2025-03-06 04:53:43', NULL),
    (147, '생성자 주입은 순환 참조 시 빈을 생성할 수 없기 때문에 애플리케이션이 실행되지 않습니다.
    해결 방법으로는
    1) 필드 주입이나 setter 주입으로 변경,
    2) @Lazy를 사용해 지연 로딩 처리,
    3) 의존성 구조 자체를 변경하여 참조를 제거하는 구조 개선이 있습니다.', '2025-03-06 15:31:20', NULL),
    (148, 'Context API는 전역 상태나 공통 데이터를 여러 컴포넌트에서 공유할 때 사용합니다.
    예를 들어 사용자 정보, 다크 모드 설정, 언어 설정 등을 context로 관리할 수 있습니다.
    Props Drilling은 여러 중간 컴포넌트를 거쳐 데이터를 전달해야 할 때 발생하는 문제이며, Context API는 이를 해결해줍니다.', '2025-03-07 02:08:57', NULL),
    (149, 'HTTPS는
    1) 암호화를 통해 도청을 방지하고,
    2) 메시지 다이제스트와 MAC 등을 통해 무결성을 보장하며,
    3) 인증서를 통해 통신 상대방이 신뢰할 수 있는지 검증합니다.
    이 세 요소가 결합되어 안전한 웹 통신이 가능합니다.', '2025-03-07 12:46:34', NULL),
    (150, '1) URI에 버전 명시: /v1/users (가장 일반적)
    2) HTTP 헤더에 버전 정보 포함
    3) 쿼리 파라미터로 전달 등 다양한 방법이 있습니다.
    URI 방식은 명확하고 직관적이며, 클라이언트와 서버의 버전 호환성 유지에 유리합니다.
    변경 시 호환성을 보장하기 위해 기존 버전도 일정 기간 유지하는 것이 좋습니다.', '2025-03-07 23:24:10', NULL),
    (151, '@Embeddable은 값 타입 클래스를 정의할 때 사용하고, @Embedded는 해당 클래스를 엔티티에 포함시킬 때 사용합니다. 주소, 기간 등의 공통 속성을 재사용하거나 객체 지향적 모델링을 위해 사용하며, 별도 테이블 없이 같은 테이블에 병합 저장됩니다.', '2025-03-08 10:01:47', NULL),
    (152, '@Profile은 특정 환경(dev, prod 등)에서만 Bean을 등록하도록 설정할 수 있는 기능입니다.
    application.yml 또는 환경변수를 통해 현재 활성화된 프로파일에 따라 조건부 빈 등록이 가능하므로, 테스트 환경과 운영 환경에서 설정을 분리하고자 할 때 유용합니다.', '2025-03-08 20:39:24', NULL),
    (153, 'useRef는 컴포넌트가 리렌더링될 때도 값이 유지되는 참조 객체를 반환합니다.
    주로 DOM 엘리먼트에 직접 접근하거나, 렌더링과 무관한 값을 유지할 때 사용됩니다.
    상태(state)와 달리 값이 변경되어도 컴포넌트가 리렌더링되지 않는 것이 특징입니다.', '2025-03-09 07:17:00', NULL),
    (154, 'Access Token은 보호 자원에 접근할 수 있도록 해주는 권한 증명이며, 짧은 유효 기간을 가집니다.
    Refresh Token은 Access Token을 갱신하기 위한 용도로 사용되며, 클라이언트에만 저장됩니다.
    ID Token은 OpenID Connect에서 사용되며, 사용자의 인증 정보(프로필 등)를 포함한 JWT입니다.', '2025-03-09 17:54:37', NULL),
    (155, '1) SAGA 패턴: 각 서비스가 자체 로컬 트랜잭션을 처리하고, 실패 시 보상 트랜잭션을 실행합니다.
    2) 이벤트 기반 비동기 트랜잭션 처리: 메시지 브로커를 통해 상태를 전파하며 eventual consistency를 유지합니다.
    분산 트랜잭션은 복잡성과 성능 문제가 크기 때문에 가능한 서비스 간 트랜잭션을 최소화하고, 도메인 설계로 해결하는 것이 중요합니다.', '2025-03-10 04:32:14', NULL),
    (156, '1) 비영속(new): 엔티티가 생성되었지만 아직 영속성 컨텍스트에 저장되지 않은 상태입니다.
    2) 영속(managed): EntityManager를 통해 저장된 상태로, 변경 감지, 1차 캐시 등의 기능이 적용됩니다.
    3) 준영속(detached): 영속 상태였다가 분리된 상태로, 더 이상 변경 감지가 일어나지 않습니다.
    4) 삭제(removed): 삭제 요청된 상태로, flush 또는 commit 시 DB에서 삭제됩니다.', '2025-03-10 15:09:51', NULL),
    (157, 'Spring Bean은 먼저 인스턴스가 생성되고, 의존성 주입이 수행된 후 초기화 메서드(@PostConstruct 또는 InitializingBean)가 호출됩니다.
    그 이후 실제 서비스에 사용됩니다. 의존성은 생성자, 필드, setter 방식으로 주입되며, 생성자 주입은 필수 의존성을 강제하는 데 유리합니다.', '2025-03-11 01:47:27', NULL),
    (158, 'useMemo는 계산 비용이 큰 연산 결과를 캐싱하여 불필요한 재계산을 방지합니다.
    그러나 연산이 가볍거나 자주 변경되는 값에 대해 사용하면 오히려 성능이 저하될 수 있습니다.
    종속성 배열이 정확하지 않으면 의도하지 않은 결과가 생기므로 주의가 필요합니다.', '2025-03-11 12:25:04', NULL),
    (159, '해싱은 데이터를 고정된 길이의 값으로 변환하며, 단방향이기 때문에 원래 값을 복원할 수 없습니다.
    비밀번호 저장, 무결성 검사 등에 사용됩니다.
    암호화는 양방향으로 데이터를 암호화/복호화하며, 민감한 정보 전송에 사용됩니다.
    대표적으로 AES, RSA가 있습니다.', '2025-03-11 23:02:41', NULL),
    (160, 'API Gateway는 외부 클라이언트 요청을 각 서비스로 라우팅하고, 인증/인가, 요청 집계, 로깅, 속도 제한 등을 수행합니다.
    이를 통해 클라이언트는 단일 진입점을 통해 다양한 서비스를 호출할 수 있고, 각 서비스는 비즈니스 로직에 집중할 수 있습니다.
    또한 보안 정책을 중앙 집중화할 수 있는 장점이 있습니다.', '2025-03-12 09:40:17', NULL),
    (161, 'QueryDsl은 타입 안전성과 자동 완성 기능을 지원하는 동적 쿼리 작성 도구입니다.
    JPQL은 문자열 기반이라 컴파일 타임에 오류를 잡기 어렵고, 복잡한 동적 쿼리 구성에 불편함이 있지만,
    QueryDsl은 자바 코드 기반으로 조건을 조합할 수 있어 유지보수성과 가독성이 뛰어납니다.
    특히 동적 검색 조건이 많을 때 유용합니다.', '2025-03-12 20:17:54', NULL),
    (162, 'readOnly = true를 설정하면 JPA는 dirty checking을 생략하고, 일부 DB에서는 읽기 전용 트랜잭션으로 성능 최적화를 적용할 수 있습니다.
    변경이 없는 단순 조회 로직에서 사용하면 성능상 이점이 있으며, 실수로 엔티티가 변경되는 것을 방지하는 데도 도움이 됩니다.', '2025-03-13 06:55:31', NULL),
    (163, 'React에서는 Context API, Redux, Recoil, Zustand 등을 사용해 전역 상태를 관리할 수 있습니다.
    Context API는 간단한 구조에 적합하며, Redux는 액션-리듀서 구조로 대규모 앱에 유리합니다.
    Recoil은 React 친화적인 문법과 비동기 지원이 특징이고, Zustand는 간결한 API와 사용 편의성이 장점입니다.', '2025-03-13 17:33:08', NULL),
    (164, 'MITM은 공격자가 통신 중간에 위치하여 데이터를 가로채거나 조작하는 공격입니다.
    이를 방지하려면 HTTPS, 인증서 검증, 데이터 암호화, HSTS 설정 등을 적용해야 합니다.
    클라이언트-서버 간 직접 통신이 보장되도록 SSL/TLS 설정을 철저히 해야 합니다.', '2025-03-14 04:10:44', NULL),
    (165, '서비스 디스커버리는 서비스의 위치(IP, 포트 등)를 동적으로 찾아주는 기능으로, 수시로 변하는 마이크로서비스 환경에서 유용합니다.
    클라이언트 측 디스커버리(Spring Cloud LoadBalancer), 서버 측 디스커버리(API Gateway + Eureka), DNS 기반 등이 있으며,
    Netflix Eureka, Consul, Kubernetes DNS가 대표적입니다.', '2025-03-14 14:48:21', NULL),
    (166, 'pub/sub은 하나의 클라이언트가 메시지를 발행(publish)하면, 해당 채널을 구독(subscribe)한 모든 클라이언트가 메시지를 수신하는 방식입니다.
    채팅 시스템, 실시간 알림 서비스, 로그 수집기 등에서 활용됩니다.
    Redis는 메시지를 저장하지 않고 즉시 전달하므로 실시간성이 중요할 때 유용합니다.', '2025-03-15 01:25:58', NULL),
    (167, '볼륨은 컨테이너의 데이터를 호스트 외부에 안전하게 저장하는 방법입니다. Docker가 직접 관리하며, 컨테이너 삭제 시에도 유지됩니다.
    바인드 마운트는 호스트의 특정 디렉토리를 컨테이너에 연결하는 방식으로, 호스트 의존성이 높습니다.
    일반적으로 볼륨이 더 안전하고 이식성이 좋습니다.', '2025-03-15 12:03:34', NULL),
    (168, 'systemctl은 systemd를 사용하는 시스템에서 서비스와 유닛(Unit)을 관리하는 명령어입니다.
    예: `systemctl start nginx`는 nginx 서비스를 시작하고, `systemctl enable nginx`는 부팅 시 자동 시작 설정입니다.
    상태 확인은 `systemctl status nginx`로 확인할 수 있습니다.', '2025-03-15 22:41:11', NULL),
    (169, 'Filebeat는 경량 로그 수집기로 파일을 모니터링하고 로그를 전달하는 데 최적화되어 있습니다.
    Logstash는 로그를 수집할 뿐 아니라 다양한 필터를 통해 구조화, 변환 작업을 수행합니다.
    Filebeat는 성능과 효율성이 뛰어나고, Logstash는 복잡한 로그 처리에 적합합니다.', '2025-03-16 09:18:48', NULL),
    (170, '@Mock은 가짜 객체(mock)를 생성하고, @InjectMocks는 해당 mock 객체들을 주입받는 객체를 생성합니다.
    예를 들어 서비스 클래스가 리포지토리를 주입받을 경우, 리포지토리를 @Mock으로 만들고,
    서비스 클래스를 @InjectMocks로 선언하면 Mockito가 자동으로 mock을 주입합니다.', '2025-03-16 19:56:25', NULL),
    (171, 'TTL은 Redis 키에 유효 기간을 설정하는 기능으로, 설정된 시간이 지나면 키가 자동으로 삭제됩니다.
    주로 세션 관리, 임시 인증 코드, 캐시 데이터 등에 활용되며, `expire` 명령어나 `setex`를 통해 설정할 수 있습니다.
    TTL을 통해 메모리 누수를 방지하고 데이터 갱신 주기를 관리할 수 있습니다.', '2025-03-17 06:34:01', NULL),
    (172, '이미지는 실행 가능한 애플리케이션을 포함한 템플릿이며, 읽기 전용입니다.
    컨테이너는 이미지를 기반으로 실행 중인 인스턴스로, 읽기/쓰기가 가능하고 상태를 가질 수 있습니다.
    이미지는 불변이며 재사용 가능하고, 컨테이너는 독립된 실행 환경을 제공합니다.', '2025-03-17 17:11:38', NULL),
    (173, '파일 권한은 소유자(user), 그룹(group), 기타(other)로 나뉘며, 각각 read(r), write(w), execute(x) 권한을 가질 수 있습니다.
    `chmod`는 숫자(755) 또는 기호(`u+x` 등)로 권한을 설정할 수 있으며, 예: `chmod 644 file.txt`는 `rw-r--r--` 권한을 의미합니다.', '2025-03-18 03:49:15', NULL),
    (174, 'Elasticsearch는 로그 데이터를 저장하고 검색하는 엔진입니다.
    Logstash는 다양한 소스에서 로그를 수집하고 필터링/변환해 Elasticsearch로 전달합니다.
    Kibana는 Elasticsearch에 저장된 로그를 시각화하는 도구로, 대시보드와 검색 기능을 제공합니다.', '2025-03-18 14:26:51', NULL),
    (175, '`@Test`는 테스트 메서드를 나타내는 어노테이션으로, 해당 메서드가 테스트 대상임을 JUnit에게 알립니다.
    메서드는 반환값이 없고 예외를 던질 수 있으며, 각 테스트는 독립적으로 실행됩니다.
    초기화용 `@BeforeEach`, 정리용 `@AfterEach` 등의 어노테이션과 함께 사용됩니다.', '2025-03-19 01:04:28', NULL),
    (176, 'AutoConfiguration은 애플리케이션에서 사용 중인 라이브러리와 설정을 기반으로 필요한 Bean을 자동으로 등록하는 기능입니다.
    내부적으로는 @Conditional 계열 어노테이션을 사용하여 조건부로 설정이 적용되며, META-INF/spring.factories에 정의된 클래스들을 기반으로 구성됩니다.', '2025-03-19 11:42:05', NULL),
    (177, 'HATEOAS(Hypermedia As The Engine Of Application State)는 클라이언트가 서버 응답에 포함된 링크를 통해 다음 행동을 알 수 있도록 하는 원칙입니다.
    이를 통해 클라이언트는 URI를 하드코딩하지 않고 동적으로 탐색할 수 있어 API의 유연성과 변경 내성이 향상됩니다.', '2025-03-19 22:19:42', NULL),
    (178, 'OAuth2 로그인은 클라이언트가 인증 요청을 보내면 인가 서버가 인가 코드를 반환하고,
    이를 통해 액세스 토큰을 발급받아 사용자 정보를 가져오는 구조입니다.
    Spring Security에서는 application.yml에서 client-id, client-secret 등을 설정하며,
    OAuth2LoginConfigurer를 통해 로그인 URL, 사용자 정보 처리 등을 설정할 수 있습니다.', '2025-03-20 08:57:18', NULL),
    (179, '1) 클라이언트가 SYN 패킷을 보냄
    2) 서버가 SYN-ACK 응답
    3) 클라이언트가 ACK로 응답하며 연결이 성립됩니다.
    이 과정은 양쪽 통신 가능 여부를 확인하고 초기 순서 번호를 동기화하여 신뢰성 있는 데이터 전송을 보장하기 위한 목적입니다.', '2025-03-20 19:34:55', NULL),
    (180, '동일한 파일의 동일한 줄을 서로 다른 브랜치에서 수정한 경우 충돌이 발생합니다.
    Git은 자동 병합이 불가능하다고 판단하고 conflict 상태로 표시합니다.
    해결 방법은 충돌 파일을 열어 수동으로 수정한 후 `git add`로 스테이징하고, `git commit`으로 병합을 완료합니다.', '2025-03-21 06:12:32', NULL),
    (181, 'Starter는 특정 기능(Spring MVC, JPA 등)을 구성하는 의존성을 모아놓은 Maven/Gradle BOM 패키지입니다.
    예: spring-boot-starter-web은 톰캣, Spring MVC, Jackson 등이 함께 포함됩니다.
    개발자는 최소 설정으로 관련 기능을 바로 사용할 수 있어 생산성이 향상됩니다.', '2025-03-21 16:50:08', NULL),
    (182, '`/getUserInfo?id=1`과 같은 동사 중심 URI는 REST 원칙에 어긋납니다.
    대신 `/users/1`처럼 리소스 중심으로 표현해야 합니다.
    URI는 명사형으로, 클라이언트가 자원의 위치를 직관적으로 이해할 수 있도록 설계하는 것이 중요합니다.', '2025-03-22 03:27:45', NULL),
    (183, 'JWT는 Header, Payload, Signature로 구성됩니다.
    Payload에 사용자 정보가 담기며, 서명을 통해 위변조를 방지합니다.
    그러나 Payload는 인코딩된 것이지 암호화되지 않았기 때문에 민감 정보를 담으면 안 됩니다.
    또한 토큰 탈취 방지를 위한 HTTPS 사용, 짧은 만료 시간, Refresh Token 분리 전략 등이 필요합니다.', '2025-03-22 14:05:22', NULL),
    (184, 'Bounded Context는 특정 도메인 모델이 의미를 가지는 경계를 정의합니다.
    동일한 개념이라도 서로 다른 컨텍스트에서는 의미나 역할이 달라질 수 있기 때문에,
    시스템을 여러 컨텍스트로 분리하고 각자의 용어와 모델을 독립적으로 유지하는 것이 중요합니다.
    마이크로서비스 아키텍처와 궁합이 좋습니다.', '2025-03-23 00:42:59', NULL),
    (185, 'rebase는 한 브랜치의 커밋들을 다른 브랜치 위로 재적용하여 히스토리를 깔끔하게 만듭니다.
    merge는 두 브랜치의 변경 사항을 통합하며 병합 커밋을 생성합니다.
    rebase는 히스토리를 직선으로 유지하지만, 이미 푸시된 브랜치에는 사용하지 않는 것이 좋습니다.', '2025-03-23 11:20:35', NULL),
    (186, 'ACID는 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 지속성(Durability)을 의미합니다.
    원자성은 모든 작업이 완전히 수행되거나 모두 취소되어야 함을 의미하고,
    일관성은 데이터 무결성이 유지되는 것을 보장합니다.
    고립성은 트랜잭션 간 간섭을 막고,
    지속성은 커밋된 데이터가 시스템 장애에도 보존됨을 보장합니다.', '2025-03-23 21:58:12', NULL),
    (187, '`application.yml` 파일 안에 `---` 구분자를 사용해 프로파일별 섹션을 만들 수 있습니다.
    예: `spring.profiles: dev`, `spring.profiles.active: dev`를 통해 개발 환경 설정을 적용할 수 있습니다.
    VM 옵션이나 환경변수로도 활성화할 수 있습니다.', '2025-03-24 08:35:49', NULL),
    (188, 'RDB는 주기적으로 메모리 전체를 스냅샷으로 저장하는 방식으로, 복구는 빠르지만 일부 데이터 손실 가능성이 있습니다.
    AOF는 모든 명령을 로그로 저장하여 높은 신뢰성을 제공합니다.
    단, 파일 크기가 크고 복구 시간이 길 수 있습니다.
    두 방식을 함께 사용하는 것도 가능합니다.', '2025-03-24 19:13:25', NULL),
    (189, 'crontab은 `분 시 일 월 요일` 형식으로 주기를 설정합니다.
    예: `0 3 * * *`는 매일 새벽 3시에 실행됩니다.
    `crontab -e`로 편집하고, 각 라인에는 주기 + 실행 명령을 작성합니다.
    로그 백업, 시스템 모니터링 스크립트 등에 자주 사용됩니다.', '2025-03-25 05:51:02', NULL),
    (190, 'PR은 특정 브랜치의 변경 사항을 main 브랜치 등으로 병합하기 전에 검토 요청하는 과정입니다.
    팀원들은 코드 스타일, 기능 정확성, 테스트 여부 등을 확인하고, 코멘트를 남기거나 변경 요청을 할 수 있습니다.
    작은 단위로 자주 PR을 생성하고, 리뷰어를 지정하며, 커밋 메시지도 명확히 작성하는 것이 좋습니다.', '2025-03-25 16:28:39', NULL),
    (191, '인덱스는 자주 조회되는 조건 컬럼에 적용하고, 선택도가 높은 컬럼이 유리합니다.
    하지만 인덱스가 너무 많으면 쓰기 성능이 떨어지고, LIKE ''%keyword'' 같은 조건은 인덱스를 활용하지 못합니다.
    불필요한 복합 인덱스나 중복 인덱스는 제거해야 하며, 실제 쿼리 패턴에 맞춘 설계가 필요합니다.', '2025-03-26 03:06:16', NULL),
    (192, 'Actuator는 `/actuator/health`, `/actuator/metrics` 등 다양한 엔드포인트를 통해 시스템 상태와 메트릭을 노출합니다.
    헬스 체크, 애플리케이션 정보 확인, 커스텀 메트릭 등록 등을 지원하며,
    운영 환경에서 시스템 상태를 외부에서 점검하고 모니터링할 때 유용합니다.', '2025-03-26 13:43:52', NULL),
    (193, 'LRU(Least Recently Used)는 가장 오래 사용하지 않은 데이터를 우선 제거하는 정책입니다.
    캐시처럼 빠른 응답이 중요한 서비스에서 유용하며, Redis에서는 `maxmemory-policy`를 설정해 적용할 수 있습니다.
    예: `maxmemory-policy allkeys-lru`.', '2025-03-27 00:21:29', NULL),
    (194, 'top 명령어로 CPU 사용률, 메모리 사용량, 개별 프로세스 상태 등을 실시간으로 확인할 수 있습니다.
    `%CPU`는 프로세스별 CPU 점유율, `%MEM`은 메모리 점유율을 나타냅니다.
    `load average`는 1, 5, 15분간의 평균 시스템 부하를 의미하며,
    1코어 기준 1.0 이상이면 과부하 상태일 수 있습니다.', '2025-03-27 10:59:06', NULL),
    (195, 'stash는 작업 중인 변경 사항을 임시로 저장하고 작업 디렉토리를 깨끗하게 만들어주는 기능입니다.
    `git stash`, `git stash pop`, `git stash list` 등이 주요 명령어입니다.
    다른 브랜치로 급히 전환해야 할 때, 작업 내용 손실 없이 안전하게 전환할 수 있습니다.', '2025-03-27 21:36:42', NULL),
    (196, 'multi-stage build는 여러 단계를 거쳐 이미지를 빌드함으로써 최종 이미지에 불필요한 의존성이나 파일을 포함하지 않게 해줍니다.
    이를 통해 이미지 크기를 줄이고 보안성을 높일 수 있습니다.
    예: 첫 번째 단계에서 빌드하고, 두 번째 단계에서는 결과물만 복사하여 실행 환경 구성.', '2025-03-28 08:14:19', NULL),
    (197, '프로세스는 독립된 메모리 공간을 가지는 실행 단위이며,
    스레드는 프로세스 내에서 메모리를 공유하는 실행 흐름입니다.
    스레드는 자원을 공유하므로 컨텍스트 스위칭 비용이 낮고, 빠른 통신이 가능하지만 동기화 문제가 발생할 수 있습니다.
    프로세스는 충돌 시 독립성이 보장됩니다.', '2025-03-28 18:51:56', NULL),
    (198, '단위 테스트는 메서드나 클래스처럼 작은 단위를 독립적으로 테스트하며, 빠르게 피드백을 받을 수 있습니다.
    통합 테스트는 여러 컴포넌트가 함께 동작하는지를 확인하며, DB, 외부 API 등 실제 환경과의 상호작용을 포함할 수 있습니다.
    각각 개발 초기와 시스템 통합 시점에 유용합니다.', '2025-03-29 05:29:33', NULL),
    (199, 'rebase는 커밋 히스토리를 재작성하는 작업으로, 이미 push된 브랜치에 대해 rebase를 하면
    협업 중인 다른 사람의 히스토리와 충돌이 발생할 수 있습니다. `force push`가 필요해지며, 잘못하면 커밋 유실 가능성이 있습니다.
    개인 브랜치에서만 사용하거나 협업 전에 팀 룰을 정하는 것이 좋습니다.', '2025-03-29 16:07:09', NULL),
    (200, 'Prometheus는 시계열 기반 모니터링 툴로, 애플리케이션의 메트릭 데이터를 수집하고 저장합니다.
    Grafana는 이 데이터를 시각화하는 대시보드 도구입니다.
    Prometheus가 수집한 메트릭을 Grafana가 쿼리해 실시간 그래프, 알림 등을 제공합니다.', '2025-03-30 02:44:46', NULL),
    (201, 'GitHub Actions는 GitHub 저장소에 기반한 워크플로 자동화 도구입니다.
    워크플로는 이벤트(trigger), 잡(job), 스텝(step), 액션(action)으로 구성됩니다.
    예: push 시 테스트 및 빌드 자동 수행, PR 시 배포 스크립트 실행 등.
    `.github/workflows` 경로에 YAML 파일로 정의되며, 다양한 커뮤니티 액션도 사용할 수 있습니다.', '2025-03-30 13:22:23', NULL);

INSERT INTO user_answer_stats
    (user_id, question_id, correct_count, wrong_count, first_solved_at, last_solved_at)
VALUES
    (1, 1, 1, 0, '2025-05-19 04:53:44', '2025-05-19 04:53:44'),
    (1, 2, 0, 1, '2025-05-03 04:53:44', '2025-05-03 04:53:44'),
    (1, 3, 0, 1, '2025-05-20 04:53:44', '2025-05-20 04:53:44'),
    (1, 4, 0, 1, '2025-05-22 04:53:44', '2025-05-22 04:53:44'),
    (1, 5, 1, 0, '2025-05-14 04:53:44', '2025-05-14 04:53:44'),
    (1, 6, 1, 0, '2025-05-22 04:53:44', '2025-05-22 04:53:44'),
    (1, 7, 1, 0, '2025-04-26 04:53:44', '2025-04-26 04:53:44'),
    (1, 8, 0, 1, '2025-04-29 04:53:44', '2025-04-29 04:53:44'),
    (1, 10, 1, 0, '2025-04-28 04:53:44', '2025-04-28 04:53:44'),
    (1, 12, 0, 1, '2025-05-22 04:53:44', '2025-05-22 04:53:44'),
    (1, 13, 0, 1, '2025-05-02 04:53:44', '2025-05-02 04:53:44'),
    (1, 16, 1, 0, '2025-04-27 04:53:44', '2025-04-27 04:53:44'),
    (1, 17, 1, 0, '2025-05-20 04:53:44', '2025-05-20 04:53:44'),
    (1, 20, 0, 1, '2025-05-23 04:53:44', '2025-05-23 04:53:44'),
    (1, 21, 0, 1, '2025-04-25 04:53:44', '2025-04-25 04:53:44'),
    (1, 22, 0, 1, '2025-04-24 04:53:44', '2025-04-24 04:53:44'),
    (1, 24, 1, 0, '2025-05-05 04:53:44', '2025-05-05 04:53:44'),
    (1, 25, 1, 0, '2025-04-23 04:53:44', '2025-04-23 04:53:44'),
    (1, 26, 1, 0, '2025-04-24 04:53:44', '2025-04-24 04:53:44'),
    (1, 27, 0, 1, '2025-05-11 04:53:44', '2025-05-11 04:53:44'),
    (1, 28, 1, 0, '2025-05-20 04:53:44', '2025-05-20 04:53:44'),
    (1, 29, 1, 0, '2025-05-01 04:53:44', '2025-05-01 04:53:44'),
    (1, 30, 0, 1, '2025-05-11 04:53:44', '2025-05-11 04:53:44'),
    (1, 31, 1, 0, '2025-05-23 04:53:44', '2025-05-23 04:53:44'),
    (1, 32, 0, 1, '2025-04-25 04:53:44', '2025-04-25 04:53:44'),
    (1, 34, 0, 1, '2025-05-15 04:53:44', '2025-05-15 04:53:44'),
    (1, 35, 0, 1, '2025-04-23 04:53:44', '2025-04-23 04:53:44'),
    (1, 37, 0, 1, '2025-05-06 04:53:44', '2025-05-06 04:53:44'),
    (1, 38, 0, 1, '2025-05-10 04:53:44', '2025-05-10 04:53:44'),
    (1, 39, 0, 1, '2025-04-26 04:53:44', '2025-04-26 04:53:44'),
    (1, 43, 1, 0, '2025-05-09 04:53:44', '2025-05-09 04:53:44'),
    (1, 44, 1, 0, '2025-05-18 04:53:44', '2025-05-18 04:53:44'),
    (1, 47, 1, 0, '2025-05-03 04:53:44', '2025-05-03 04:53:44'),
    (1, 48, 0, 1, '2025-05-02 04:53:44', '2025-05-02 04:53:44'),
    (1, 49, 0, 1, '2025-05-23 04:53:44', '2025-05-23 04:53:44'),
    (1, 50, 0, 1, '2025-05-18 04:53:44', '2025-05-18 04:53:44'),
    (1, 51, 0, 1, '2025-04-30 04:53:44', '2025-04-30 04:53:44'),
    (1, 52, 1, 0, '2025-04-26 04:53:44', '2025-04-26 04:53:44'),
    (1, 53, 1, 0, '2025-05-13 04:53:44', '2025-05-13 04:53:44'),
    (1, 54, 1, 0, '2025-05-09 04:53:44', '2025-05-09 04:53:44'),
    (1, 55, 0, 1, '2025-05-11 04:53:44', '2025-05-11 04:53:44'),
    (1, 56, 0, 1, '2025-05-21 04:53:44', '2025-05-21 04:53:44'),
    (1, 57, 1, 0, '2025-05-17 04:53:44', '2025-05-17 04:53:44'),
    (1, 58, 1, 0, '2025-05-07 04:53:44', '2025-05-07 04:53:44'),
    (1, 59, 1, 0, '2025-05-07 04:53:44', '2025-05-07 04:53:44'),
    (1, 60, 0, 1, '2025-05-02 04:53:44', '2025-05-02 04:53:44'),
    (1, 62, 1, 0, '2025-05-23 04:53:44', '2025-05-23 04:53:44'),
    (1, 63, 0, 1, '2025-04-24 04:53:44', '2025-04-24 04:53:44'),
    (1, 64, 1, 0, '2025-05-22 04:53:44', '2025-05-22 04:53:44'),
    (1, 65, 0, 1, '2025-05-15 04:53:44', '2025-05-15 04:53:44'),
    (1, 66, 1, 0, '2025-05-23 04:53:44', '2025-05-23 04:53:44'),
    (1, 70, 1, 0, '2025-05-21 04:53:44', '2025-05-21 04:53:44'),
    (1, 71, 1, 0, '2025-04-23 04:53:44', '2025-04-23 04:53:44'),
    (1, 72, 1, 0, '2025-04-30 04:53:44', '2025-04-30 04:53:44'),
    (1, 74, 1, 0, '2025-04-30 04:53:44', '2025-04-30 04:53:44'),
    (1, 75, 0, 1, '2025-05-18 04:53:44', '2025-05-18 04:53:44'),
    (1, 78, 1, 0, '2025-04-24 04:53:44', '2025-04-24 04:53:44'),
    (1, 80, 1, 0, '2025-04-23 04:53:44', '2025-04-23 04:53:44'),
    (1, 81, 1, 0, '2025-05-22 04:53:44', '2025-05-22 04:53:44'),
    (1, 85, 1, 0, '2025-05-19 05:53:44', '2025-05-19 05:53:44'),
    (1, 86, 0, 1, '2025-05-04 04:53:44', '2025-05-04 04:53:44'),
    (1, 87, 1, 0, '2025-04-28 04:53:44', '2025-04-28 04:53:44'),
    (1, 90, 1, 0, '2025-05-19 04:53:44', '2025-05-19 04:53:44'),
    (1, 91, 1, 0, '2025-04-29 04:53:44', '2025-04-29 04:53:44'),
    (1, 92, 0, 1, '2025-05-14 04:53:44', '2025-05-14 04:53:44'),
    (1, 93, 0, 1, '2025-05-01 04:53:44', '2025-05-01 04:53:44'),
    (1, 94, 0, 1, '2025-05-15 04:53:44', '2025-05-15 04:53:44'),
    (1, 95, 1, 0, '2025-05-09 04:53:44', '2025-05-09 04:53:44'),
    (1, 96, 0, 1, '2025-05-11 04:53:44', '2025-05-11 04:53:44'),
    (1, 100, 1, 0, '2025-05-18 04:53:44', '2025-05-18 04:53:44'),
    (1, 103, 0, 1, '2025-05-22 04:53:44', '2025-05-22 04:53:44'),
    (1, 104, 0, 1, '2025-05-07 04:53:44', '2025-05-07 04:53:44'),
    (1, 105, 0, 1, '2025-05-21 04:53:44', '2025-05-21 04:53:44'),
    (1, 106, 0, 1, '2025-05-17 04:53:44', '2025-05-17 04:53:44'),
    (1, 109, 1, 0, '2025-05-23 04:53:44', '2025-05-23 04:53:44'),
    (1, 110, 0, 1, '2025-05-12 04:53:44', '2025-05-12 04:53:44'),
    (1, 111, 1, 0, '2025-05-10 04:53:44', '2025-05-10 04:53:44'),
    (1, 114, 0, 1, '2025-04-25 04:53:44', '2025-04-25 04:53:44'),
    (1, 115, 0, 1, '2025-05-18 04:53:44', '2025-05-18 04:53:44'),
    (1, 116, 0, 1, '2025-05-13 04:53:44', '2025-05-13 04:53:44'),
    (1, 117, 1, 0, '2025-05-01 04:53:44', '2025-05-01 04:53:44'),
    (1, 118, 1, 0, '2025-05-09 04:53:44', '2025-05-09 04:53:44'),
    (1, 119, 0, 1, '2025-05-10 04:53:44', '2025-05-10 04:53:44'),
    (1, 120, 0, 1, '2025-05-17 04:53:44', '2025-05-17 04:53:44'),
    (1, 121, 1, 0, '2025-05-20 04:53:44', '2025-05-20 04:53:44'),
    (1, 122, 1, 0, '2025-04-30 04:53:44', '2025-04-30 04:53:44'),
    (1, 124, 1, 0, '2025-05-16 04:53:44', '2025-05-16 04:53:44'),
    (1, 125, 0, 1, '2025-05-05 04:53:44', '2025-05-05 04:53:44'),
    (1, 126, 0, 1, '2025-05-19 04:53:44', '2025-05-19 04:53:44'),
    (1, 127, 0, 1, '2025-05-22 04:53:44', '2025-05-22 04:53:44'),
    (1, 128, 0, 1, '2025-04-26 04:53:44', '2025-04-26 04:53:44'),
    (1, 129, 1, 0, '2025-05-22 04:53:44', '2025-05-22 04:53:44'),
    (1, 130, 0, 1, '2025-05-12 04:53:44', '2025-05-12 04:53:44'),
    (1, 133, 1, 0, '2025-05-04 04:53:44', '2025-05-04 04:53:44'),
    (1, 134, 0, 1, '2025-04-23 04:53:44', '2025-04-23 04:53:44'),
    (1, 135, 0, 1, '2025-05-09 04:53:44', '2025-05-09 04:53:44'),
    (1, 136, 1, 0, '2025-05-05 04:53:44', '2025-05-05 04:53:44'),
    (1, 138, 1, 0, '2025-05-11 04:53:44', '2025-05-11 04:53:44'),
    (1, 139, 1, 0, '2025-05-14 04:53:44', '2025-05-14 04:53:44'),
    (1, 140, 0, 1, '2025-04-27 04:53:44', '2025-04-27 04:53:44'),
    (1, 141, 1, 0, '2025-05-05 04:53:44', '2025-05-05 04:53:44'),
    (1, 143, 0, 1, '2025-05-03 04:53:44', '2025-05-03 04:53:44'),
    (1, 145, 0, 1, '2025-04-27 04:53:44', '2025-04-27 04:53:44'),
    (1, 146, 1, 0, '2025-05-09 04:53:44', '2025-05-09 04:53:44'),
    (1, 147, 0, 1, '2025-05-12 04:53:44', '2025-05-12 04:53:44'),
    (1, 148, 1, 0, '2025-04-27 04:53:44', '2025-04-27 04:53:44'),
    (1, 149, 0, 1, '2025-05-18 04:53:44', '2025-05-18 04:53:44'),
    (1, 152, 1, 0, '2025-05-21 04:53:44', '2025-05-21 04:53:44'),
    (1, 153, 1, 0, '2025-05-06 04:53:44', '2025-05-06 04:53:44'),
    (1, 156, 0, 1, '2025-04-23 04:53:44', '2025-04-23 04:53:44'),
    (1, 157, 1, 0, '2025-05-19 04:53:44', '2025-05-19 04:53:44'),
    (1, 158, 1, 0, '2025-05-06 04:53:44', '2025-05-06 04:53:44'),
    (1, 159, 0, 1, '2025-05-20 04:53:44', '2025-05-20 04:53:44'),
    (1, 161, 1, 0, '2025-05-23 04:53:44', '2025-05-23 04:53:44'),
    (1, 162, 1, 0, '2025-04-28 04:53:44', '2025-04-28 04:53:44'),
    (1, 163, 1, 0, '2025-05-22 04:53:44', '2025-05-22 04:53:44'),
    (1, 164, 1, 0, '2025-05-13 04:53:44', '2025-05-13 04:53:44'),
    (1, 165, 1, 0, '2025-05-12 04:53:44', '2025-05-12 04:53:44'),
    (1, 166, 1, 0, '2025-05-07 04:53:44', '2025-05-07 04:53:44'),
    (1, 167, 0, 1, '2025-05-17 04:53:44', '2025-05-17 04:53:44'),
    (1, 169, 1, 0, '2025-05-14 04:53:44', '2025-05-14 04:53:44'),
    (1, 171, 0, 1, '2025-05-12 04:53:44', '2025-05-12 04:53:44'),
    (1, 175, 1, 0, '2025-05-08 04:53:44', '2025-05-08 04:53:44'),
    (1, 176, 1, 0, '2025-05-17 04:53:44', '2025-05-17 04:53:44'),
    (1, 179, 1, 0, '2025-05-15 04:53:44', '2025-05-15 04:53:44'),
    (1, 180, 0, 1, '2025-04-23 04:53:44', '2025-04-23 04:53:44'),
    (1, 181, 0, 1, '2025-05-23 04:53:44', '2025-05-23 04:53:44'),
    (1, 182, 0, 1, '2025-05-19 04:53:44', '2025-05-19 04:53:44'),
    (1, 183, 1, 0, '2025-05-06 04:53:44', '2025-05-06 04:53:44'),
    (1, 184, 1, 0, '2025-05-21 04:53:44', '2025-05-21 04:53:44'),
    (1, 185, 1, 0, '2025-05-09 04:53:44', '2025-05-09 04:53:44'),
    (1, 186, 0, 1, '2025-04-25 04:53:44', '2025-04-25 04:53:44'),
    (1, 187, 1, 0, '2025-05-09 04:53:44', '2025-05-09 04:53:44'),
    (1, 188, 0, 1, '2025-05-10 04:53:44', '2025-05-10 04:53:44'),
    (1, 189, 1, 0, '2025-05-11 04:53:44', '2025-05-11 04:53:44'),
    (1, 194, 0, 1, '2025-04-29 04:53:44', '2025-04-29 04:53:44'),
    (1, 195, 0, 1, '2025-05-20 04:53:44', '2025-05-20 04:53:44'),
    (1, 196, 0, 1, '2025-05-19 04:53:44', '2025-05-19 04:53:44'),
    (1, 198, 0, 1, '2025-04-26 04:53:44', '2025-04-26 04:53:44'),
    (1, 199, 0, 1, '2025-04-26 04:53:44', '2025-04-26 04:53:44'),
    (1, 200, 1, 0, '2025-05-01 04:53:44', '2025-05-01 04:53:44');

INSERT INTO user_answers
    (user_id, question_id, answer_text, is_correct, created_at)
VALUES
    (1, 1, 'Checked 예외는 컴파일 타임에 처리 강제, Unchecked 예외는 런타임에 발생합니다. 예를 들어 FileNotFoundException은 반드시 try-catch로 처리해야 합니다. 사용자 정의 예외는 도메인 로직에서 의미 있는 오류를 표현할 때 사용하며, 서비스의 예외 흐름을 명확하게 만드는 데 도움이 됩니다. `extends RuntimeException`으로 정의하고, 메시지와 상태 코드 등을 포함할 수 있습니다.', 1, '2025-05-19 04:53:44'),
    (1, 2, '모르겠습니다.', 0, '2025-05-03 04:53:44'),
    (1, 3, '모르겠습니다.', 0, '2025-05-20 04:53:44'),
    (1, 4, '모르겠습니다.', 0, '2025-05-22 04:53:44'),
    (1, 5, '이미지를 경량화하려면 다음과 같은 전략을 사용합니다. 다단계 빌드(multi-stage build)로 불필요한 빌드 도구 제거, 불필요한 파일은 `.dockerignore`로 제외, base 이미지로 `alpine`과 같은 경량 이미지를 사용, 레이어 수를 줄이기 위해 RUN 명령어를 하나로 묶기', 1, '2025-05-14 04:53:44'),
    (1, 6, 'JVM 메모리는 메서드 영역, 힙, 스택, PC 레지스터, 네이티브 메서드 스택으로 구성됩니다. GC는 주로 힙 영역에서 동작하며, Young, Old, Metaspace로 구분됩니다. 객체는 Eden → Survivor → Old 순으로 이동하며, Young GC는 Minor GC, Old GC는 Major 또는 Full GC로 처리됩니다. GC 알고리즘에는 G1, CMS, Serial 등이 있으며, 각각의 특징에 따라 성능과 처리 방식이 달라집니다.', 1, '2025-05-22 04:53:44'),
    (1, 7, '로드 밸런싱에는 라운드로빈, Least Connection, IP 해시 방식 등이 있습니다. 라운드로빈은 순차적으로 분배해 간단하지만, 처리량이 다른 서버에서는 부적절할 수 있습니다. Least Connection은 현재 연결 수가 적은 서버에 요청을 보내 효율적이지만 상태 추적 비용이 듭니다. IP 해시는 클라이언트 고정 세션에 적합하지만 서버 추가 시 해시 충돌 문제가 발생할 수 있습니다.', 1, '2025-04-26 04:53:44'),
    (1, 8, '모르겠습니다.', 0, '2025-04-29 04:53:44'),
    (1, 10, 'INNER JOIN은 두 테이블에 모두 존재하는 데이터만, LEFT JOIN은 왼쪽 테이블 기준으로, RIGHT JOIN은 오른쪽 테이블 기준으로 NULL 포함 결과를 반환합니다. FULL OUTER JOIN은 양쪽 모두 포함하며, 주로 PostgreSQL 등에서 지원됩니다. 예: 사용자와 주문 테이블에서 INNER JOIN은 주문한 사용자만, LEFT JOIN은 모든 사용자와 그들의 주문(없으면 NULL)을 보여줍니다.', 1, '2025-04-28 04:53:44'),
    (1, 12, '모르겠습니다.', 0, '2025-05-22 04:53:44'),
    (1, 13, '모르겠습니다.', 0, '2025-05-02 04:53:44'),
    (1, 16, '인덱스는 조회 성능을 크게 높여주지만, 과도한 인덱스는 쓰기 성능을 저하시키고 디스크 공간도 낭비합니다. 자주 검색되거나 JOIN, WHERE, ORDER BY에 자주 등장하는 컬럼에 적용하는 것이 효과적입니다. 다중 컬럼 인덱스의 경우 컬럼 순서에 따라 활용도가 달라지므로 주의가 필요하며, 실제 실행 계획(EXPLAIN)을 보고 검증하는 것이 좋습니다.', 1, '2025-04-27 04:53:44'),
    (1, 17, '트리 쉐이킹은 사용되지 않는 코드(dead code)를 제거하여 번들 크기를 줄이는 기법입니다. ES Module 기반의 정적 분석이 가능할 때 작동하며, 불필요한 유틸 함수나 라이브러리 일부만 사용하는 경우 번들 용량을 최적화할 수 있습니다. side-effect가 있는 모듈은 제대로 제거되지 않을 수 있으므로 `sideEffects: false` 설정을 통해 안전하게 적용할 수 있습니다.', 1, '2025-05-19 04:53:44'),
    (1, 20, '모르겠습니다.', 0, '2025-05-23 04:53:44'),
    (1, 21, '모르겠습니다.', 0, '2025-04-25 04:53:44'),
    (1, 22, '모르겠습니다.', 0, '2025-04-24 04:53:44'),
    (1, 24, '@EnableAutoConfiguration 어노테이션이 META-INF/spring.factories 파일에 정의된 설정 클래스를 기반으로 동작합니다. 조건부 빈 등록을 위해 @Conditional 계열 어노테이션이 사용되며, 특정 자동 구성을 끄려면 `spring.autoconfigure.exclude` 설정을 사용하거나 @SpringBootApplication의 exclude 속성을 지정할 수 있습니다.', 1, '2025-05-05 04:53:44'),
    (1, 25, 'HTTP Keep-Alive는 하나의 TCP 연결을 통해 여러 HTTP 요청/응답을 처리할 수 있게 해주는 기능입니다. 이를 통해 매 요청마다 연결을 재설정하는 오버헤드를 줄이고, 네트워크 효율성을 높이며 응답 속도도 개선할 수 있습니다. 대부분의 웹 서버와 브라우저는 기본적으로 이 기능을 지원합니다.', 1, '2025-04-23 04:53:44'),
    (1, 26, '영속성 컨텍스트는 엔티티 객체를 관리하는 JPA의 핵심 개념으로, 동일 트랜잭션 내에서 같은 엔티티를 공유하도록 1차 캐시를 제공합니다. 변경 감지는 트랜잭션 종료 시점에 엔티티 상태를 스냅샷과 비교하여 변경된 필드를 찾아 자동으로 UPDATE 쿼리를 생성합니다. 이는 dirty checking이라고도 하며, 명시적으로 save()를 호출하지 않아도 변경 내용을 반영할 수 있습니다.', 1, '2025-04-24 04:53:44'),
    (1, 27, '모르겠습니다.', 0, '2025-05-11 04:53:44'),
    (1, 28, '연결 설정은 SYN → SYN-ACK → ACK의 3단계를 거치며, 클라이언트와 서버가 모두 통신 가능함을 확인합니다. 연결 종료는 FIN → ACK → FIN → ACK의 4단계로 진행되며, 송수신이 모두 완료된 후에 자원을 해제합니다. 종료 시 TIME_WAIT 상태가 유지되어 중복된 세그먼트로 인한 문제를 방지합니다.', 1, '2025-05-20 04:53:44'),
    (1, 29, 'CSR은 브라우저에서 JS가 렌더링을 처리하며, 초기 로딩이 느리지만 이후 사용자 경험은 부드럽습니다. SPA에 적합합니다. SSR은 서버에서 HTML을 렌더링해 초기 응답 속도가 빠르며, 검색 엔진 최적화(SEO)에 유리합니다. 블로그나 마케팅 페이지처럼 초기 로딩이 중요한 곳에 적합합니다.', 1, '2025-05-01 04:53:44'),
    (1, 30, '모르겠습니다.', 0, '2025-05-11 04:53:44'),
    (1, 31, '포워드 프록시는 클라이언트가 직접 접근할 수 없는 서버의 리소스를 요청할 때 중개 역할을 하며, 주로 내부 사용자 익명화나 필터링 목적에 사용됩니다. 반면 리버스 프록시는 클라이언트 요청을 받아 실제 서버로 전달하고, 응답을 대신 반환하는 구조로 로드 밸런싱, SSL 종료, 캐싱 등에 활용됩니다. Nginx는 대표적인 리버스 프록시입니다.', 1, '2025-05-23 04:53:44'),
    (1, 32, '모르겠습니다.', 0, '2025-04-25 04:53:44'),
    (1, 34, '모르겠습니다.', 0, '2025-05-15 04:53:44'),
    (1, 35, '모르겠습니다.', 0, '2025-04-23 04:53:44'),
    (1, 37, '모르겠습니다.', 0, '2025-05-06 04:53:44'),
    (1, 38, '모르겠습니다.', 0, '2025-05-10 04:53:44'),
    (1, 39, '모르겠습니다.', 0, '2025-04-26 04:53:44'),
    (1, 43, '샤딩은 수평적 분산으로, 데이터를 여러 DB 인스턴스에 나눠 저장합니다. 반면 파티셔닝은 하나의 DB 내에서 데이터를 논리적으로 구분합니다. 샤딩은 서비스 확장을 위해 사용되며, 파티셔닝은 주로 쿼리 성능 향상이나 관리 편의를 위해 사용됩니다. 샤딩은 운영 복잡성이 더 크지만, 대규모 분산 환경에서 유리합니다.', 1, '2025-05-09 04:53:44'),
    (1, 44, '사용자는 클라이언트를 통해 인증 요청을 보내면, 인증 서버는 인가 코드를 발급합니다. 클라이언트는 이 코드를 가지고 다시 인증 서버에 접근해 액세스 토큰을 요청하고, 서버는 클라이언트의 인증 정보와 함께 코드를 검증한 후 토큰을 발급합니다. 이 방식은 보안상 가장 강력하며, 서버 간 통신으로 토큰을 주고받기 때문에 클라이언트 측 노출이 없습니다.', 1, '2025-05-18 04:53:44'),
    (1, 47, 'persist()는 JPA 표준 EntityManager의 메서드로, 새 엔티티만 영속화할 수 있습니다. 이미 존재하는 식별자가 있는 엔티티에는 IllegalArgumentException이 발생합니다. 반면 save()는 Spring Data JPA에서 제공하는 메서드로, 새 엔티티는 persist, 이미 존재하는 엔티티는 merge 동작을 합니다. 결과적으로 save()는 범용적으로 편리하지만, 의도치 않은 merge가 발생할 수 있어 주의가 필요합니다.', 1, '2025-05-03 04:53:44'),
    (1, 48, '모르겠습니다.', 0, '2025-05-02 04:53:44'),
    (1, 49, '모르겠습니다.', 0, '2025-05-23 04:53:44'),
    (1, 50, '모르겠습니다.', 0, '2025-05-18 04:53:44'),
    (1, 51, '모르겠습니다.', 0, '2025-04-30 04:53:44'),
    (1, 52, 'cascade는 부모 엔티티의 작업(persist, remove 등)을 연관된 자식 엔티티에 자동으로 전파하는 설정입니다. 예를 들어 부모를 저장할 때 자식도 함께 저장되도록 하려면 CascadeType.PERSIST를 사용합니다. 하지만 잘못 설정하면 예기치 않게 대량 삭제나 저장이 발생할 수 있어, 관계 방향성과 생명주기를 명확히 이해하고 설정해야 합니다.', 1, '2025-04-26 04:53:44'),
    (1, 53, 'SPA는 클라이언트 라우팅을 통해 페이지를 전환하며, 전체 페이지를 다시 로드하지 않고 필요한 컴포넌트만 교체합니다. react-router 등의 라이브러리를 사용하며, 상태 관리는 useState, useContext, Redux, Recoil 등의 도구를 통해 전역 또는 로컬 상태를 관리합니다. 비동기 데이터는 React Query나 SWR로 처리하기도 합니다.', 1, '2025-05-13 04:53:44'),
    (1, 54, 'Redis pub/sub은 발행자(Publisher)가 메시지를 채널에 발행하면, 구독자(Subscriber)가 해당 채널을 통해 메시지를 수신하는 방식입니다. 메시지는 휘발성이며 저장되지 않습니다. 실무에서는 채팅 시스템, 알림 전송, 실시간 로그 모니터링 등에 사용되며, 메시지 유실이 치명적인 경우 Kafka와 같은 메시지 큐를 함께 사용하기도 합니다.', 1, '2025-05-09 04:53:44'),
    (1, 55, '모르겠습니다.', 0, '2025-05-11 04:53:44'),
    (1, 56, '모르겠습니다.', 0, '2025-05-21 04:53:44'),
    (1, 57, '세션 방식은 서버가 사용자 상태를 메모리 또는 DB에 저장하고 세션 ID를 클라이언트에 보냅니다. JWT는 클라이언트가 상태 정보를 포함한 토큰을 저장하며, 서버는 상태를 저장하지 않아 확장성이 뛰어납니다. JWT는 서버 간 인증 공유에 유리하지만, 토큰 무효화가 어렵고 탈취 시 위험합니다. 세션은 제어가 쉽지만 서버 부하가 늘어납니다.', 1, '2025-05-17 04:53:44'),
    (1, 58, 'React에서는 memo, useMemo, useCallback 등의 훅을 활용해 불필요한 렌더링을 방지할 수 있습니다. 또한, key 값을 안정적으로 부여하고, 무거운 연산은 useMemo로 메모이제이션하며, props 변경이 적은 하위 컴포넌트는 React.memo로 감쌉니다. Virtualized List 사용, 코드 스플리팅도 성능 최적화에 도움됩니다.', 1, '2025-05-07 04:53:44'),
    (1, 59, 'HTTP는 데이터를 암호화하지 않고 전송하는 반면, HTTPS는 SSL/TLS를 이용해 데이터를 암호화합니다. 이 과정을 통해 중간자 공격, 도청, 위조를 방지할 수 있습니다. TLS는 대칭키 기반의 암호화를 제공하며, 대칭키 전달은 공개키 암호화 방식으로 보장됩니다. 또한, 인증서를 통해 서버 신원을 검증합니다.', 1, '2025-05-07 04:53:44'),
    (1, 60, '모르겠습니다.', 0, '2025-05-02 04:53:44'),
    (1, 62, '@Value는 개별 설정값을 바로 주입할 수 있어 간단하지만, 복잡한 구조나 다수의 값을 주입할 때는 불편하고 유지보수가 어렵습니다. 반면 @ConfigurationProperties는 계층적 구조를 객체 단위로 주입할 수 있어 타입 안정성과 재사용성이 높습니다. 대규모 설정을 다룰 때는 @ConfigurationProperties가 적합합니다.', 1, '2025-05-23 04:53:44'),
    (1, 63, '모르겠습니다.', 0, '2025-04-24 04:53:44'),
    (1, 64, '전역 상태는 여러 컴포넌트에서 공유되어야 하는 로그인 정보, 테마 설정, 장바구니 데이터 등에서 필요합니다. Context API는 간단한 전역 상태에 적합하며, 상태가 복잡해지면 Redux, Recoil, Zustand 등의 상태 관리 도구를 사용할 수 있습니다. React Query는 서버 상태를 전역처럼 다루는 데 유용합니다.', 1, '2025-05-22 04:53:44'),
    (1, 65, '모르겠습니다.', 0, '2025-05-15 04:53:44'),
    (1, 66, '정규화는 데이터 중복을 제거하고, 데이터 무결성을 보장하기 위해 테이블을 구조화하는 과정입니다. 제1정규형(1NF), 제2정규형(2NF), 제3정규형(3NF) 등이 있으며 각 단계마다 종속성과 중복을 줄입니다. 장점은 저장 공간 절약과 이상현상 방지, 단점은 조인이 많아져 성능이 저하될 수 있다는 점입니다. 실무에서는 정규화와 비정규화를 적절히 혼합합니다.', 1, '2025-05-23 04:53:44'),
    (1, 70, 'CDN은 사용자와 가까운 위치의 엣지 서버에서 정적 자원을 제공함으로써 응답 속도와 안정성을 높여줍니다. 캐시 갱신을 위해선 파일명에 해시값을 붙이거나, Cache-Control 헤더를 활용해 만료 시간을 설정합니다. 버전 관리와 캐시 무효화 정책을 함께 설계해야 예상치 못한 오래된 리소스가 전달되는 문제를 방지할 수 있습니다.', 1, '2025-05-21 04:53:44'),
    (1, 71, '인터페이스는 구현을 가지지 않는 계약이며, 다중 구현이 가능합니다. 추상 클래스는 공통 구현을 포함할 수 있고 단일 상속만 가능합니다. 공통 로직이 있다면 추상 클래스, 역할 중심의 설계라면 인터페이스가 적합합니다. Java 8 이후 인터페이스도 default 메서드로 일부 구현이 가능하지만, 상태(필드)는 가질 수 없습니다.', 1, '2025-04-23 04:53:44'),
    (1, 72, 'merge()는 준영속 상태의 엔티티를 영속성 컨텍스트에 다시 병합하는 데 사용됩니다. 기존 DB에 있는 값과 병합된 새 객체를 반환하며, 원래 객체는 여전히 준영속 상태입니다. 실수로 잘못된 데이터가 덮어씌워질 수 있으므로, 반드시 병합 전 데이터를 검증해야 하며, 가능한 persist() 사용을 우선 고려하는 것이 안전합니다.', 1, '2025-04-30 04:53:44'),
    (1, 74, 'GET은 리소스 조회, POST는 리소스 생성, PUT은 전체 업데이트, PATCH는 일부 업데이트, DELETE는 리소스 삭제에 사용됩니다. GET은 안전하고 캐시가 가능하며, POST는 데이터 전송량 제한이 적고 멱등성이 없습니다. PUT과 DELETE는 멱등성 보장, PATCH는 부분 변경에 유리합니다.', 1, '2025-04-30 04:53:44'),
    (1, 75, '모르겠습니다.', 0, '2025-05-18 04:53:44'),
    (1, 78, 'key는 React가 각 요소를 식별할 수 있게 하여 효율적인 가상 DOM 비교를 가능하게 합니다. 고유하고 예측 가능한 값을 key로 지정해야 하며, index를 key로 사용하면 요소 순서 변경 시 불필요한 렌더링이나 상태 꼬임이 발생할 수 있습니다. 주로 데이터의 고유 ID를 key로 사용하는 것이 권장됩니다.', 1, '2025-04-24 04:53:44'),
    (1, 80, '동기 처리는 요청이 완료될 때까지 다음 작업을 기다리는 방식이고, 비동기는 요청과 응답이 분리되어 작업이 병렬로 진행됩니다. 예: 동기는 파일을 읽고 그 결과를 기다리는 방식, 비동기는 콜백이나 이벤트 루프를 통해 처리됩니다. REST API 호출 시 비동기 처리는 응답 속도 개선과 자원 활용 최적화에 유리합니다.', 1, '2025-04-23 04:53:44'),
    (1, 81, '1) 같은 클래스 내부에서 메서드를 호출할 경우 프록시를 거치지 않아 적용되지 않습니다. 2) private 메서드에는 적용되지 않습니다. 3) 예외가 발생해도 CheckedException일 경우 rollback이 되지 않습니다. 4) 클래스에 등록되지 않은 일반 객체에서 @Transactional을 사용할 경우 적용되지 않습니다.', 1, '2025-05-22 04:53:44'),
    (1, 85, '1) 블루-그린 배포: 기존 서버와 새 서버를 병렬 운영하고, 트래픽을 전환함으로써 배포 중단 없이 전환합니다. 2) 롤링 배포: 서버를 순차적으로 교체하며 전체를 점진적으로 업데이트합니다. 3) Canary 배포: 소수 트래픽으로 배포를 테스트한 후 점진적으로 확장합니다. 헬스 체크와 자동 롤백 설정이 필수입니다.', 1, '2025-05-19 04:53:44'),
    (1, 86, '모르겠습니다.', 0, '2025-05-04 04:53:44'),
    (1, 87, 'EAGER는 엔티티 로딩 시 연관 엔티티도 즉시 함께 로딩하며, LAZY는 실제 사용 시점에 쿼리를 실행합니다. 기본적으로 LAZY를 사용하는 것이 성능과 유연성 측면에서 유리하며, EAGER는 예상치 못한 조인으로 N+1 문제가 발생할 수 있습니다. 즉시 사용이 확실한 경우에만 EAGER를 고려해야 합니다.', 1, '2025-04-28 04:53:44'),
    (1, 90, '테스트 자동화는 배포 전 코드 품질을 검증하고 버그를 조기에 발견하기 위해 중요합니다. 보통 코드 커밋 시 단위 테스트, 통합 테스트가 실행되며, Jenkins, GitHub Actions 등의 도구로 구성합니다. 테스트 커버리지 도구(Jacoco 등)를 연동해 품질 기준을 설정하고, 실패 시 배포가 중단되도록 설정하는 것이 일반적입니다.', 1, '2025-05-19 04:53:44'),
    (1, 91, 'RESTful URI는 명사 중심, 리소스 기반, 계층적 구조로 설계되어야 하며, 동사를 URI에 넣지 않아야 합니다. 예: `/users/1/orders`는 사용자 1의 주문 목록을 의미합니다. `/getUser`와 같은 동사 기반 URI는 안티패턴입니다. URI는 상태가 아니라 리소스를 표현하며, 일관성, 예측 가능성, 소문자 표기 등을 유지해야 합니다.', 1, '2025-04-29 04:53:44'),
    (1, 92, '모르겠습니다.', 0, '2025-05-14 04:53:44'),
    (1, 93, '모르겠습니다.', 0, '2025-05-01 04:53:44'),
    (1, 94, '모르겠습니다.', 0, '2025-05-15 04:53:44'),
    (1, 95, 'OAuth 2.0은 리소스 접근 권한을 위임하는 프레임워크이고, OpenID Connect는 OAuth 2.0 위에 인증 기능을 추가한 프로토콜입니다. OAuth는 ''누군가의 리소스를 대신 사용하기 위한 인증''이며, OpenID Connect는 ''사용자가 누구인지 증명하는 인증''입니다. OpenID Connect는 ID 토큰을 통해 사용자 정보까지 제공합니다.', 1, '2025-05-09 04:53:44'),
    (1, 96, '모르겠습니다.', 0, '2025-05-11 04:53:44'),
    (1, 100, 'Authorization Code는 서버 간 통신을 통한 보안성이 높은 방식으로, 대부분의 앱에서 권장됩니다. Implicit은 브라우저 기반 클라이언트에 사용되며 현재는 권장되지 않습니다. Password는 사용자 인증 정보를 직접 받기 때문에 보안상 위험하며, 신뢰된 앱에서만 사용됩니다. Client Credentials는 사용자 없이 서버 간 인증에 사용됩니다.', 1, '2025-05-18 04:53:44'),
    (1, 103, '모르겠습니다.', 0, '2025-05-22 04:53:44'),
    (1, 104, '모르겠습니다.', 0, '2025-05-07 04:53:44'),
    (1, 105, '모르겠습니다.', 0, '2025-05-21 04:53:44'),
    (1, 106, '모르겠습니다.', 0, '2025-05-17 04:53:44'),
    (1, 109, 'XSS는 악의적인 스크립트 코드를 웹 페이지에 삽입하여 사용자의 쿠키, 세션 등을 탈취하거나 조작하는 공격입니다. 방어 전략으로는 입력 값 검증,  출력 시 HTML Escape 처리,  Content Security Policy(CSP) 설정,  HTTPOnly, Secure 옵션 설정이 있으며, 프레임워크 단에서 기본적으로 제공하는 XSS 방지 필터도 활용해야 합니다.', 1, '2025-05-23 04:53:44'),
    (1, 110, '모르겠습니다.', 0, '2025-05-12 04:53:44'),
    (1, 111, 'Cascade는 부모 엔티티의 영속/삭제 등의 작업이 자식에게 전파되도록 합니다. 예: CascadeType.ALL. OrphanRemoval은 부모와의 연관관계가 제거된 자식 엔티티를 자동으로 삭제합니다. 둘의 차이는 Cascade는 ''작업 전파'', OrphanRemoval은 ''연결 해제 시 삭제''라는 점이며, 둘을 함께 사용할 수도 있습니다.', 1, '2025-05-10 04:53:44'),
    (1, 114, '모르겠습니다.', 0, '2025-04-25 04:53:44'),
    (1, 115, '모르겠습니다.', 0, '2025-05-18 04:53:44'),
    (1, 116, '모르겠습니다.', 0, '2025-05-13 04:53:44'),
    (1, 117, 'BeanFactory는 DI의 가장 기본적인 컨테이너이며 Lazy 방식으로 Bean을 로딩합니다. ApplicationContext는 BeanFactory를 확장한 구조로, 메시지 리소스 처리, 이벤트 발행, AOP 연동, 국제화 등 다양한 기능을 제공합니다. 대부분의 실무에서는 ApplicationContext를 사용합니다.', 1, '2025-05-01 04:53:44'),
    (1, 118, 'useMemo는 연산된 값을 메모이제이션하여 재계산을 방지하고, useCallback은 함수를 메모이제이션하여 함수 재생성을 방지합니다. useMemo는 값, useCallback은 함수 자체를 캐싱하며, 종속성 배열이 동일할 경우 이전 결과를 재사용합니다.', 1, '2025-05-09 04:53:44'),
    (1, 119, '모르겠습니다.', 0, '2025-05-10 04:53:44'),
    (1, 120, '모르겠습니다.', 0, '2025-05-17 04:53:44'),
    (1, 121, '@Version은 낙관적 락을 적용하기 위한 필드에 붙으며, 엔티티가 수정될 때마다 해당 버전 필드가 자동 증가합니다. 업데이트 시점에 DB에 저장된 버전과 현재 버전이 다르면 OptimisticLockException이 발생하여 충돌을 감지합니다. 이 방식은 충돌 가능성이 낮은 시스템에 적합합니다.', 1, '2025-05-20 04:53:44'),
    (1, 122, '@ComponentScan은 컴포넌트 클래스(@Component, @Service 등)를 자동으로 검색해 Bean으로 등록합니다. 기본적으로 선언된 클래스의 패키지 하위부터 스캔하며, basePackages 속성을 지정하면 스캔 범위를 수동으로 조정할 수 있습니다. 계층 구조가 복잡한 프로젝트에서 유용합니다.', 1, '2025-04-30 04:53:44'),
    (1, 124, '예: `id='' OR ''1''=''1` 같은 입력으로 WHERE 조건을 항상 true로 만들어 전체 테이블을 조회하거나 삭제할 수 있습니다. 방어 방법은 PreparedStatement 사용,  입력값 유효성 검증,  ORM 사용,  최소 권한의 DB 계정 운영,  에러 메시지 노출 금지 등이 있습니다.', 1, '2025-05-16 04:53:44'),
    (1, 125, '모르겠습니다.', 0, '2025-05-05 04:53:44'),
    (1, 126, '모르겠습니다.', 0, '2025-05-19 04:53:44'),
    (1, 127, '모르겠습니다.', 0, '2025-05-22 04:53:44'),
    (1, 128, '모르겠습니다.', 0, '2025-04-26 04:53:44'),
    (1, 129, '기밀성은 인가되지 않은 접근으로부터 데이터를 보호하는 것(예: 암호화), 무결성은 데이터가 위변조되지 않았음을 보장하는 것(예: 해시, 서명), 가용성은 필요한 사용자가 데이터를 사용할 수 있도록 하는 것(예: 서버 이중화, 장애 대응)을 의미합니다.', 1, '2025-05-22 04:53:44'),
    (1, 130, '모르겠습니다.', 0, '2025-05-12 04:53:44'),
    (1, 133, '1) useEffect + useState를 조합해 직접 API 호출과 상태를 관리할 수 있습니다. 2) useReducer로 상태 관리 분기를 명확히 할 수 있습니다. 3) React Query, SWR 같은 라이브러리를 사용하면 캐싱, 리트라이, 로딩 처리 등이 자동화되어 편리합니다. 복잡한 상태가 많아지면 Redux-Toolkit도 사용할 수 있습니다.', 1, '2025-05-04 04:53:44'),
    (1, 134, '모르겠습니다.', 0, '2025-04-23 04:53:44'),
    (1, 135, '모르겠습니다.', 0, '2025-05-09 04:53:44'),
    (1, 136, '@JoinColumn은 외래 키 컬럼의 이름을 명시할 때 사용합니다. 생략하면 JPA는 기본 네이밍 전략에 따라 컬럼명을 생성합니다. 이를 명시적으로 설정하지 않으면 컬럼명이 예상과 다를 수 있고, 여러 연관관계가 있을 경우 충돌이 발생할 수도 있습니다. 따라서 명확한 매핑을 위해 명시적으로 설정하는 것이 좋습니다.', 1, '2025-05-05 04:53:44'),
    (1, 138, 'key는 React가 각 컴포넌트를 고유하게 식별하여 효율적으로 렌더링할 수 있도록 도와줍니다. index를 key로 사용할 경우 요소 추가/삭제 시 잘못된 상태 전달이나 렌더링 오류가 발생할 수 있습니다. 가능한 고유 ID를 사용하는 것이 안전합니다.', 1, '2025-05-11 04:53:44'),
    (1, 139, 'Access Token이 만료되었을 때 사용자는 다시 로그인하지 않고 Refresh Token을 통해 새로운 Access Token을 발급받을 수 있습니다. Refresh Token은 보안상의 이유로 서버에서 안전하게 저장되어야 하며, 탈취 위험에 대비한 재사용 제한, 만료 정책 등이 함께 적용되어야 합니다.', 1, '2025-05-14 04:53:44'),
    (1, 140, '모르겠습니다.', 0, '2025-04-27 04:53:44'),
    (1, 141, 'JPQL은 객체 지향 쿼리 언어로 엔티티 기반으로 작성되며, 데이터베이스 독립성을 보장받을 수 있습니다. 반면 Native Query는 SQL을 직접 작성하는 방식으로 복잡한 쿼리나 성능 최적화가 필요한 경우 사용합니다. JPQL은 유지보수성이 좋고 타입 안전하지만, 복잡한 쿼리 작성에는 한계가 있으며, Native Query는 데이터베이스 종속적이지만 강력한 표현력을 가집니다.', 1, '2025-05-05 04:53:44'),
    (1, 143, '모르겠습니다.', 0, '2025-05-03 04:53:44'),
    (1, 145, '모르겠습니다.', 0, '2025-04-27 04:53:44'),
    (1, 146, 'fetch join은 연관된 엔티티를 함께 조회하여 N+1 문제를 해결하는 JPQL 문법입니다. join fetch를 사용하면 연관된 데이터를 한 번의 쿼리로 가져올 수 있습니다. 하지만 컬렉션을 여러 개 fetch join하면 중복 데이터가 생기고, 페이징 처리에 문제가 발생할 수 있으므로 필요한 상황에서만 신중하게 사용해야 합니다.', 1, '2025-05-09 04:53:44'),
    (1, 147, '모르겠습니다.', 0, '2025-05-12 04:53:44'),
    (1, 148, 'Context API는 전역 상태나 공통 데이터를 여러 컴포넌트에서 공유할 때 사용합니다. 예를 들어 사용자 정보, 다크 모드 설정, 언어 설정 등을 context로 관리할 수 있습니다. Props Drilling은 여러 중간 컴포넌트를 거쳐 데이터를 전달해야 할 때 발생하는 문제이며, Context API는 이를 해결해줍니다.', 1, '2025-04-27 04:53:44'),
    (1, 149, '모르겠습니다.', 0, '2025-05-18 04:53:44'),
    (1, 152, '@Profile은 특정 환경(dev, prod 등)에서만 Bean을 등록하도록 설정할 수 있는 기능입니다. application.yml 또는 환경변수를 통해 현재 활성화된 프로파일에 따라 조건부 빈 등록이 가능하므로, 테스트 환경과 운영 환경에서 설정을 분리하고자 할 때 유용합니다.', 1, '2025-05-21 04:53:44'),
    (1, 153, 'useRef는 컴포넌트가 리렌더링될 때도 값이 유지되는 참조 객체를 반환합니다. 주로 DOM 엘리먼트에 직접 접근하거나, 렌더링과 무관한 값을 유지할 때 사용됩니다. 상태(state)와 달리 값이 변경되어도 컴포넌트가 리렌더링되지 않는 것이 특징입니다.', 1, '2025-05-06 04:53:44'),
    (1, 156, '모르겠습니다.', 0, '2025-04-23 04:53:44'),
    (1, 157, 'Spring Bean은 먼저 인스턴스가 생성되고, 의존성 주입이 수행된 후 초기화 메서드(@PostConstruct 또는 InitializingBean)가 호출됩니다. 그 이후 실제 서비스에 사용됩니다. 의존성은 생성자, 필드, setter 방식으로 주입되며, 생성자 주입은 필수 의존성을 강제하는 데 유리합니다.', 1, '2025-05-19 04:53:44'),
    (1, 158, 'useMemo는 계산 비용이 큰 연산 결과를 캐싱하여 불필요한 재계산을 방지합니다. 그러나 연산이 가볍거나 자주 변경되는 값에 대해 사용하면 오히려 성능이 저하될 수 있습니다. 종속성 배열이 정확하지 않으면 의도하지 않은 결과가 생기므로 주의가 필요합니다.', 1, '2025-05-06 04:53:44'),
    (1, 159, '모르겠습니다.', 0, '2025-05-20 04:53:44'),
    (1, 161, 'QueryDsl은 타입 안전성과 자동 완성 기능을 지원하는 동적 쿼리 작성 도구입니다. JPQL은 문자열 기반이라 컴파일 타임에 오류를 잡기 어렵고, 복잡한 동적 쿼리 구성에 불편함이 있지만, QueryDsl은 자바 코드 기반으로 조건을 조합할 수 있어 유지보수성과 가독성이 뛰어납니다. 특히 동적 검색 조건이 많을 때 유용합니다.', 1, '2025-05-23 04:53:44'),
    (1, 162, 'readOnly = true를 설정하면 JPA는 dirty checking을 생략하고, 일부 DB에서는 읽기 전용 트랜잭션으로 성능 최적화를 적용할 수 있습니다. 변경이 없는 단순 조회 로직에서 사용하면 성능상 이점이 있으며, 실수로 엔티티가 변경되는 것을 방지하는 데도 도움이 됩니다.', 1, '2025-04-28 04:53:44'),
    (1, 163, 'React에서는 Context API, Redux, Recoil, Zustand 등을 사용해 전역 상태를 관리할 수 있습니다. Context API는 간단한 구조에 적합하며, Redux는 액션-리듀서 구조로 대규모 앱에 유리합니다. Recoil은 React 친화적인 문법과 비동기 지원이 특징이고, Zustand는 간결한 API와 사용 편의성이 장점입니다.', 1, '2025-05-22 04:53:44'),
    (1, 164, 'MITM은 공격자가 통신 중간에 위치하여 데이터를 가로채거나 조작하는 공격입니다. 이를 방지하려면 HTTPS, 인증서 검증, 데이터 암호화, HSTS 설정 등을 적용해야 합니다. 클라이언트-서버 간 직접 통신이 보장되도록 SSL/TLS 설정을 철저히 해야 합니다.', 1, '2025-05-13 04:53:44'),
    (1, 165, '서비스 디스커버리는 서비스의 위치(IP, 포트 등)를 동적으로 찾아주는 기능으로, 수시로 변하는 마이크로서비스 환경에서 유용합니다. 클라이언트 측 디스커버리(Spring Cloud LoadBalancer), 서버 측 디스커버리(API Gateway + Eureka), DNS 기반 등이 있으며, Netflix Eureka, Consul, Kubernetes DNS가 대표적입니다.', 1, '2025-05-12 04:53:44'),
    (1, 166, 'pub/sub은 하나의 클라이언트가 메시지를 발행(publish)하면, 해당 채널을 구독(subscribe)한 모든 클라이언트가 메시지를 수신하는 방식입니다. 채팅 시스템, 실시간 알림 서비스, 로그 수집기 등에서 활용됩니다. Redis는 메시지를 저장하지 않고 즉시 전달하므로 실시간성이 중요할 때 유용합니다.', 1, '2025-05-07 04:53:44'),
    (1, 167, '모르겠습니다.', 0, '2025-05-17 04:53:44'),
    (1, 169, 'Filebeat는 경량 로그 수집기로 파일을 모니터링하고 로그를 전달하는 데 최적화되어 있습니다. Logstash는 로그를 수집할 뿐 아니라 다양한 필터를 통해 구조화, 변환 작업을 수행합니다. Filebeat는 성능과 효율성이 뛰어나고, Logstash는 복잡한 로그 처리에 적합합니다.', 1, '2025-05-14 04:53:44'),
    (1, 171, '모르겠습니다.', 0, '2025-05-12 04:53:44'),
    (1, 175, '`@Test`는 테스트 메서드를 나타내는 어노테이션으로, 해당 메서드가 테스트 대상임을 JUnit에게 알립니다. 메서드는 반환값이 없고 예외를 던질 수 있으며, 각 테스트는 독립적으로 실행됩니다. 초기화용 `@BeforeEach`, 정리용 `@AfterEach` 등의 어노테이션과 함께 사용됩니다.', 1, '2025-05-08 04:53:44'),
    (1, 176, 'AutoConfiguration은 애플리케이션에서 사용 중인 라이브러리와 설정을 기반으로 필요한 Bean을 자동으로 등록하는 기능입니다. 내부적으로는 @Conditional 계열 어노테이션을 사용하여 조건부로 설정이 적용되며, META-INF/spring.factories에 정의된 클래스들을 기반으로 구성됩니다.', 1, '2025-05-17 04:53:44'),
    (1, 179, '1) 클라이언트가 SYN 패킷을 보냄 2) 서버가 SYN-ACK 응답 3) 클라이언트가 ACK로 응답하며 연결이 성립됩니다. 이 과정은 양쪽 통신 가능 여부를 확인하고 초기 순서 번호를 동기화하여 신뢰성 있는 데이터 전송을 보장하기 위한 목적입니다.', 1, '2025-05-15 04:53:44'),
    (1, 180, '모르겠습니다.', 0, '2025-04-23 04:53:44'),
    (1, 181, '모르겠습니다.', 0, '2025-05-23 04:53:44'),
    (1, 182, '모르겠습니다.', 0, '2025-05-19 04:53:44'),
    (1, 183, 'JWT는 Header, Payload, Signature로 구성됩니다. Payload에 사용자 정보가 담기며, 서명을 통해 위변조를 방지합니다. 그러나 Payload는 인코딩된 것이지 암호화되지 않았기 때문에 민감 정보를 담으면 안 됩니다. 또한 토큰 탈취 방지를 위한 HTTPS 사용, 짧은 만료 시간, Refresh Token 분리 전략 등이 필요합니다.', 1, '2025-05-06 04:53:44'),
    (1, 184, 'Bounded Context는 특정 도메인 모델이 의미를 가지는 경계를 정의합니다. 동일한 개념이라도 서로 다른 컨텍스트에서는 의미나 역할이 달라질 수 있기 때문에, 시스템을 여러 컨텍스트로 분리하고 각자의 용어와 모델을 독립적으로 유지하는 것이 중요합니다. 마이크로서비스 아키텍처와 궁합이 좋습니다.', 1, '2025-05-21 04:53:44'),
    (1, 185, 'rebase는 한 브랜치의 커밋들을 다른 브랜치 위로 재적용하여 히스토리를 깔끔하게 만듭니다. merge는 두 브랜치의 변경 사항을 통합하며 병합 커밋을 생성합니다. rebase는 히스토리를 직선으로 유지하지만, 이미 푸시된 브랜치에는 사용하지 않는 것이 좋습니다.', 1, '2025-05-09 04:53:44'),
    (1, 186, '모르겠습니다.', 0, '2025-04-25 04:53:44'),
    (1, 187, '`application.yml` 파일 안에 `---` 구분자를 사용해 프로파일별 섹션을 만들 수 있습니다. 예: `spring.profiles: dev`, `spring.profiles.active: dev`를 통해 개발 환경 설정을 적용할 수 있습니다. VM 옵션이나 환경변수로도 활성화할 수 있습니다.', 1, '2025-05-09 04:53:44'),
    (1, 188, '모르겠습니다.', 0, '2025-05-10 04:53:44'),
    (1, 189, 'crontab은 `분 시 일 월 요일` 형식으로 주기를 설정합니다. 예: `0 3 * * *`는 매일 새벽 3시에 실행됩니다. `crontab -e`로 편집하고, 각 라인에는 주기 + 실행 명령을 작성합니다. 로그 백업, 시스템 모니터링 스크립트 등에 자주 사용됩니다.', 1, '2025-05-11 04:53:44'),
    (1, 194, '모르겠습니다.', 0, '2025-04-29 04:53:44'),
    (1, 195, '모르겠습니다.', 0, '2025-05-20 04:53:44'),
    (1, 196, '모르겠습니다.', 0, '2025-05-19 04:53:44'),
    (1, 198, '모르겠습니다.', 0, '2025-04-26 04:53:44'),
    (1, 199, '모르겠습니다.', 0, '2025-04-26 04:53:44'),
    (1, 200, 'Prometheus는 시계열 기반 모니터링 툴로, 애플리케이션의 메트릭 데이터를 수집하고 저장합니다. Grafana는 이 데이터를 시각화하는 대시보드 도구입니다. Prometheus가 수집한 메트릭을 Grafana가 쿼리해 실시간 그래프, 알림 등을 제공합니다.', 1, '2025-05-01 04:53:44');

INSERT INTO wrong_answers
    (user_id, question_id, created_at)
VALUES
    (1, 2, '2025-05-03 04:53:44'),
    (1, 3, '2025-05-20 04:53:44'),
    (1, 4, '2025-05-22 04:53:44'),
    (1, 8, '2025-04-29 04:53:44'),
    (1, 12, '2025-05-22 04:53:44'),
    (1, 13, '2025-05-02 04:53:44'),
    (1, 20, '2025-05-23 04:53:44'),
    (1, 21, '2025-04-25 04:53:44'),
    (1, 22, '2025-04-24 04:53:44'),
    (1, 27, '2025-05-11 04:53:44'),
    (1, 30, '2025-05-11 04:53:44'),
    (1, 32, '2025-04-25 04:53:44'),
    (1, 34, '2025-05-15 04:53:44'),
    (1, 35, '2025-04-23 04:53:44'),
    (1, 37, '2025-05-06 04:53:44'),
    (1, 38, '2025-05-10 04:53:44'),
    (1, 39, '2025-04-26 04:53:44'),
    (1, 48, '2025-05-02 04:53:44'),
    (1, 49, '2025-05-23 04:53:44'),
    (1, 50, '2025-05-18 04:53:44'),
    (1, 51, '2025-04-30 04:53:44'),
    (1, 55, '2025-05-11 04:53:44'),
    (1, 56, '2025-05-21 04:53:44'),
    (1, 60, '2025-05-02 04:53:44'),
    (1, 63, '2025-04-24 04:53:44'),
    (1, 65, '2025-05-15 04:53:44'),
    (1, 75, '2025-05-18 04:53:44'),
    (1, 86, '2025-05-04 04:53:44'),
    (1, 92, '2025-05-14 04:53:44'),
    (1, 93, '2025-05-01 04:53:44'),
    (1, 94, '2025-05-15 04:53:44'),
    (1, 96, '2025-05-11 04:53:44'),
    (1, 103, '2025-05-22 04:53:44'),
    (1, 104, '2025-05-07 04:53:44'),
    (1, 105, '2025-05-21 04:53:44'),
    (1, 106, '2025-05-17 04:53:44'),
    (1, 110, '2025-05-12 04:53:44'),
    (1, 114, '2025-04-25 04:53:44'),
    (1, 115, '2025-05-18 04:53:44'),
    (1, 116, '2025-05-13 04:53:44'),
    (1, 119, '2025-05-10 04:53:44'),
    (1, 120, '2025-05-17 04:53:44'),
    (1, 125, '2025-05-05 04:53:44'),
    (1, 126, '2025-05-19 04:53:44'),
    (1, 127, '2025-05-22 04:53:44'),
    (1, 128, '2025-04-26 04:53:44'),
    (1, 130, '2025-05-12 04:53:44'),
    (1, 134, '2025-04-23 04:53:44'),
    (1, 135, '2025-05-09 04:53:44'),
    (1, 140, '2025-04-27 04:53:44'),
    (1, 143, '2025-05-03 04:53:44'),
    (1, 145, '2025-04-27 04:53:44'),
    (1, 147, '2025-05-12 04:53:44'),
    (1, 149, '2025-05-18 04:53:44'),
    (1, 156, '2025-04-23 04:53:44'),
    (1, 159, '2025-05-20 04:53:44'),
    (1, 167, '2025-05-17 04:53:44'),
    (1, 171, '2025-05-12 04:53:44'),
    (1, 180, '2025-04-23 04:53:44'),
    (1, 181, '2025-05-23 04:53:44'),
    (1, 182, '2025-05-19 04:53:44'),
    (1, 186, '2025-04-25 04:53:44'),
    (1, 188, '2025-05-10 04:53:44'),
    (1, 194, '2025-04-29 04:53:44'),
    (1, 195, '2025-05-20 04:53:44'),
    (1, 196, '2025-05-19 04:53:44'),
    (1, 198, '2025-04-26 04:53:44'),
    (1, 199, '2025-04-26 04:53:44');